<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>Java内存模型和Volatile</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">jvm<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label8" class="tags__li tags-btn">网络<span class="post_count"></span></li>
          <li id="js-label9" class="tags__li tags-btn">工作<span class="post_count"></span></li>
          <li id="js-label10" class="tags__li tags-btn">设计<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2015/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B8%A9%E7%9A%84%E5%87%A0%E4%B8%AA(%E5%B8%B8%E8%AF%86)%E5%9D%91.html"><span class="pl__circle"></span><span class="pl__title">消息中心开发过程中踩的几个(常识)坑</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/08/17/%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">异常</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/08/17/Restful%20API%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83.html"><span class="pl__circle"></span><span class="pl__title">Restful API 的设计规范</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/InnoDB%20%E9%94%81.html"><span class="pl__circle"></span><span class="pl__title">InnoDB 锁</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/INSERT%20ON%20DUPLICATE%20KEY%20UPDATE%20%E5%87%A0%E4%B8%AA%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">INSERT ON DUPLICATE KEY UPDATE 几个要注意的问题</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2015/05/05/GIT%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html"><span class="pl__circle"></span><span class="pl__title">GIT常用操作</span><span class="pl__date">May 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/04/02/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">常用设计模式的总结</span><span class="pl__date">Apr 2015</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/09/11/ThreadLocal%20%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">ThreadLocal 分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/04/MapReduce%20Algorithms.html"><span class="pl__circle"></span><span class="pl__title">MapReduce Algorithms</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/09/03/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Skyline监控系统工作原理分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%20timeseries%E5%BC%82%E5%B8%B8%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Skyline timeseries异常判定算法</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">排序总结</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"><span class="pl__circle"></span><span class="pl__title">快速排序</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">几个常见的概率问题</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/31/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html"><span class="pl__circle"></span><span class="pl__title">常见的HTTP状态码</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/28/BloomFilter.html"><span class="pl__circle"></span><span class="pl__title">BloomFilter</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="jvm pl__all" href="/jvm/2014/07/27/gc.html"><span class="pl__circle"></span><span class="pl__title">JVM GC调优</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">二叉树的各种遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">JDK 中的并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型和Volatile</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C及虚拟内存总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache & False Sharing & 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">Java内存模型和Volatile</h1>
  <div style="line-height: 1.5; color: #2c3f51;">
<div></div>
<div>
</div><div>

<p style="margin: 0 0 1.1em;"></p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">1. 什么是 JMM？</h2>
<p style="margin: 0 0 1.1em;">JMM屏蔽掉底层不同平台的差异，在语言层面为程序员提供一个抽象的内存模型，它的核心是一系列关于<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">指令乱序</code>的规则，java语言层面上提供的<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">volatile</code>和<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">monitor机制</code>是其中的两个重点。</p>
<p style="margin: 0 0 1.1em;">有两个方面会导致指令的乱序执行：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><strong style="font-weight: bold;">编译器重排序</strong></li>
<li><strong style="font-weight: bold;">CPU 重排序</strong></li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">2. 编译器的重排序</h2>
<p style="margin: 0 0 1.1em;">编译器（对 java 而言是 JIT 编译器）在保证 <strong style="font-weight: bold;">单线程语义正确</strong> 的前提下，为了优化性能，可以任意对指令重新排序。这对单线程不会产生影响，但在并发环境下就可能导致问题。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">2.1 Compiler Memory Barrier</h3>
<p style="margin: 0 0 1.1em;">在其他未提供统一内存模型的语言中(如C)，需要使用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Compiler Memory Barrier</code>显式告诉编译器停止重排序：以该Barrier为分割线，Barrier上方的指令不可以重排序到下方，反之亦然。</p>
<p style="margin: 0 0 1.1em;">C中，不同的编译器需要不同的指令：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">__asm__ __volatile__ (<span style="color: #e6db74;">""</span> ::: <span style="color: #e6db74;">"memory"</span>); <span style="color: #75715e;">// GNU</span>
__memory_barrier(); <span style="color: #75715e;">// Intel ECC Compiler</span>
_ReadWriteBarrier(); <span style="color: #75715e;">// Microsoft Visual C++</span></code></pre>
<p style="margin: 0 0 1.1em;">这些指令是针对编译器的，不会对CPU起作用。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">2.2 JMM 对编译器重排序的规定</h3>
<p style="margin: 0 0 1.1em;">JMM在为编译器重排序定义了如下规则（NO表示不可重排序）：</p>
<table style="border-collapse: collapse; border-spacing: 0; margin-bottom: 20px;">
<thead>
<tr>
<th style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">1nd \\\ 2nd</th>
<th style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">Normal Load / Normal Store</th>
<th style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">Volatile Load / Monitor Enter</th>
<th style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">Volatile Store / Monitor Exit</th>
</tr>
</thead>
<tbody><tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">Normal Load / Normal Store</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
</tr>
<tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">Volatile Load / Monitor Enter</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
</tr>
<tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">Volatile store / Monitor Exit</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NO</td>
</tr>
</tbody></table>
<blockquote style="padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;">
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Monitor Enter</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Monitor Exit</code> 分别对应 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Sychronized</code> 块的进入和离开。</p>
</blockquote>
<p style="margin: 0 0 1.1em;">简单地说就是在3类地方禁止编译器重排序：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403762671001.png" name="d6e30d03-880d-4961-b607-eb924270f492" src="/assets/img/d08f4d58e9f50ecfc929b199829526c4.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile 读</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Sychronized 块的进入</code> 与 <strong style="font-weight: bold;">后续任意读写</strong> 不可重排；</li>
<li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile 写</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Sychronized 块的离开</code> 与 <strong style="font-weight: bold;">之前任意读写</strong> 不可重排；</li>
<li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile 写</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Sychronized 块的离开</code> 与后续 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile 读</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Sychronized 块的进入</code> 不可重排。</li>
</ol>
<p style="margin: 0 0 1.1em;">这几处和后面提到的 CPU指令重排序 是一致的。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">3. CPU 重排序（<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Reordering</code>）</h2>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Rerdering</code>指的是在 CPU 在执行程序时， 对内存地址的 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">load</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">store</code> 指令 <strong style="font-weight: bold;">实际完成的顺序 与 发起指令的顺序 不一致</strong></p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.1 为什么会出现<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Reordering</code>？</h3>
<p style="margin: 0 0 1.1em;">CPU 为了避免慢速的内存访问拖累指令的执行速度，一个常用的技巧是：将对cache或内存的<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">load</code>/<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">store</code>指令缓冲至 CPU 内部的 pipeline，对其（异步地）优化后再执行，如重排序(比如先执行命中 cache 的指令，或者将地址相近的指令放在一起执行) / 合并对同一地址的读或写 / 直接从 write buffer 中 load 数据等等，以尽量避免 cache miss，并减少对内存的访问。这是一个生产者消费者模型。</p>
<p style="margin: 0 0 1.1em;">此外，为了充分利用多级流水线，CPU 的 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">预测执行 speculative execution</code> 机制会根据以往的执行情况，在一个判断条件还没得到结果时预先执行概率大的分支并缓存结果，如果条件判断通过则直接使用该中间结果，这也会导致指令的乱序。</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403925881122.png" name="21102672-fa20-41fd-889e-58c2eb93baf5" src="/assets/img/fd9868241dc03d1519b75f4ed3ad547b.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">如图所示，CPU 的执行单元与 cache 之间还存在着各种 buffer，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">load store</code>指令会先进入这些 buffer 中排队。当指令一旦被 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">flush</code> 到 cache ，MESI 缓存一致性协议将保证数据对所有 CPU 可见。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.2 什么情况允许<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Reordering</code>？</h3>
<p style="margin: 0 0 1.1em;">CPU 进行 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Reordering</code> 的前提是保证单线程下语义的正确性，这和编译器重排序遵循的规则是一样的。更进一步的，对于存在<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">数据依赖性</code>的指令不允许重排序。</p>
<p style="margin: 0 0 1.1em;">数据依赖分下列三种类型：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>写后读  <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">a = 1;b = a;</code>  写一个变量之后，再读这个位置。</li>
<li>写后写  <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">a = 1;a = 2;</code>  写一个变量之后，再写这个变量。</li>
<li>读后写  <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">a = b;b = 1;</code>  读一个变量之后，再写这个变量。</li>
</ol>
<p style="margin: 0 0 1.1em;">上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p style="margin: 0 0 1.1em;">对于存在<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">控制依赖性</code>的代码也可能发生重排序，如：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #f92672;">if</span>(ready)
    b = a * a</code></pre>
<p style="margin: 0 0 1.1em;">假如对 ready 的 load 发生了 cache miss，为了不阻塞指令执行， CPU 可能会采用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">猜测执行</code>的手段，预先 load a，并计算<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">a * a</code>的结果放入 buffer；待 ready 的 load 完成后，如果为 true，再将计算结果取出，执行 b 的 store 动作。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.3 CPU Memory Barrier</h3>
<p style="margin: 0 0 1.1em;">CPU 自身只能保证单线程下的serial 的语义，但在并发程序中，我们经常需要 <strong style="font-weight: bold;">保证多线程之间内存操作的有序性</strong>，这依赖我们手动在合适的地方插入内存屏障，禁止单线程内某种形式的重排序。</p>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Load</code> <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Store</code> 两两组合，一共存在4种乱序，因此对应的有4种 barrier：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadLoad</code></li>
<li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadStore</code></li>
<li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreStore</code></li>
<li><p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code></p>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code>乱序可能导致所谓的 <strong style="font-weight: bold;">可见性</strong> 问题，对同一个内存地址的访问，某些 CPU 在执行 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Load</code> 时允许直接从 StoreBuffer 中取其最近一次的 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Store</code> 返回，显然这可能导致拿到过时的数据；注意，前提是两次指令 <strong style="font-weight: bold;">访问同一个地址</strong>。 </p>
<p style="margin: 0 0 1.1em;">当前所有主流 CPU 对 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad barrier</code> 的实现都包括了其他3个 barrier 的效果（这不是必须的，只是现实如此），因此，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad barrier</code> 通常也被当做 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Full Barrier</code> 使用。</p></li>
</ol>
<p style="margin: 0 0 1.1em;">使用标志位是不同的线程间进行通信的一种常见手段，此时需要借助 Memory Barrier 保证多线程间的有序性。一个简单的例子如下：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #75715e;">// 初始状态</span>
a = <span style="color: #ae81ff;">0</span>;
ready = <span style="color: #f92672;">false</span>;

<span style="color: #75715e;">// Thread 1</span>
a = <span style="color: #ae81ff;">1</span>;
ready = <span style="color: #f92672;">true</span>;

<span style="color: #75715e;">// Thread 2</span>
<span style="color: #f92672;">if</span>(ready)
    <span style="color: #e6db74;">print</span> a  <span style="color: #75715e;">// 可能打印0</span>
<span style="color: #75715e;">/* 
或者：
c = ready
d = a; 
*/</span></code></pre>
<p style="margin: 0 0 1.1em;">在这个例子中，Thread 1试图用 ready 传递 a 已经被赋值的信号，但是存在两个问题：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>Thread 1 对 a 和 ready 的<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Store</code>动作有可能<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreStore</code>乱序，导致 ready 为 true 时，Thread 2看到的 a 依然是0。因此，在 Thread 1 中必须在 a 和 ready 的store 动作之间插入 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreStore barrier</code>，保证外部在看到 ready 为 true 时，a 必然已被修改；</li>
<li>即使 Thread 1 保证了 Store 有序，Thread 2 依然可能发生 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadLoad</code> 乱序。对 a 的 Load 操作可能发生在 ready 的 Load 之前，因此下面的执行顺序是有可能的：</li>
</ol>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">Thread <span style="color: #ae81ff;">1</span>                Thread <span style="color: #ae81ff;">2</span>
=========               ===========
                            Load <span style="color: #ae81ff;">a</span>  (<span style="color: #ae81ff;">0</span>)
<span style="color: #ae81ff;">a</span> = <span style="color: #ae81ff;">1</span>
&lt;StoreStore barrier&gt;
ready = <span style="color: #ae81ff;">true</span>
                            Load ready (<span style="color: #ae81ff;">true</span>)
                            判断通过
                            print <span style="color: #ae81ff;">a</span></code></pre>
<p style="margin: 0 0 1.1em;">因此，在 Thread 2 中必须用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadLoad barrier</code>保证 a 和 ready 两个 Load 动作的顺序性。</p>
<p style="margin: 0 0 1.1em;">由此可见，内存屏障 <strong style="font-weight: bold;">只能保证执行该屏障的 CPU 的内存顺序性</strong>，如果两个线程依赖读写某些相同变量进行通信，只在某一端使用屏障是不够的，另一端也必须根据自己的逻辑加上对应的内存屏障。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.4 硬件内存模型</h3>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Memory Model</code>指定了 CPU 允许哪些指令重排序的发生，越多，内存一致性越弱；越少，内存一致性就越强。</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403942010009.png" name="d0cb91ea-2429-4fbb-a241-85a67bea3aa6" src="/assets/img/3f85cd91f478831a157afc5179bccf2b.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">常见的 x86 平台只允许 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code> 乱序，因此它的内存模型属于强一致性。</p>
<p style="margin: 0 0 1.1em;">不同平台上这四种 memory barrier 对应的指令如下，其中 x86 因为只支持<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code>乱序，所以只提供了<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad Barrier (亦即Full Barrier)</code>: <br/>
<img alt="Alt text" class="en-media" longdesc="./1403942922620.png" name="02590cd0-d583-4bc4-b7fd-f6fbd78c6c78" src="/assets/img/aaddce10fc3455e3fdc05bca8e83ff62.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.5 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire barrier</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release barrier</code></h3>
<p style="margin: 0 0 1.1em;">在实际应用中，4种按乱序情况的分法太细粒度了，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire barrier</code> 、 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release barrier</code> 是一种更粗粒度，也更常用的分类方式；</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403943796180.png" name="8969be04-7e20-4a15-8b1c-743a04539398" src="/assets/img/41491455e62a0c75bf08d2d5c155ddc3.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">即：</p>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>Read-Acquire = LoadLoad + LoadStore;</li>
<li>Write-Release = LoadStore + StoreStore.</li>
</ul>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> <br/>
具有 Read-Acquire 语义的 Read 操作保证，所有后续的读写只有在该 Read 执行完毕后才能执行。</p>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> <br/>
具有 Write-Release 语义的 Write 操作保证，只有之前的所有读写都已经执行完毕，该 write 才能执行。</p>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire barrier</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release barrier</code> 总是成对使用的，<strong style="font-weight: bold;">保证不同线程间对内存操作的顺序性</strong>：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403959603491.png" name="c9a6da91-e94d-4935-87d2-44b713c9ab6b" src="/assets/img/43fe44f8dfcd17efb0a19880fd8d7c2d.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">还是举上面的例子，用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code>和<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> barrier 的方式如下：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #75715e;">// 初始状态</span>
a = <span style="color: #ae81ff;">0</span>;
ready = <span style="color: #f92672;">false</span>;

<span style="color: #75715e;">// Thread 1</span>
a = <span style="color: #ae81ff;">1</span>;
write_release_barrier();
ready = <span style="color: #f92672;">true</span>;

<span style="color: #75715e;">// Thread 2</span>
<span style="color: #f92672;">if</span>(ready){
    read_acquire_barrier();    
    print a
}</code></pre>
<p style="margin: 0 0 1.1em;">此时，我们 <strong style="font-weight: bold;">为 ready 这个变量赋予了 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> 语义</strong>，对它的读或写动作与前后的其他 load/store 动作确立了先后关系. 当 Thread 2 发现 ready 为 true 时，a 的 store 必然已经完成，必然为1; 而 a 的 load 也不会比 ready 的 load 先完成.</p>
<p style="margin: 0 0 1.1em;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> 语义也被广泛应用在锁的实现中，<strong style="font-weight: bold;">加锁 和 释放锁 分别附带了<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> 语义，保证了 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">加锁 --&gt; load/store</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">load/store --&gt; 释放锁</code> 这两个指令序列之间的偏序关系</strong>，这样当某个线程获取了锁时，它可以确信前一个线程在释放锁之前所做的操作已经全部完成了。</p>
<p style="margin: 0 0 1.1em;">接下来会看到，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> 和 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> 是 JMM 的核心。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.6 JMM 对 CPU Memory Reordering 的规则</h3>
<p style="margin: 0 0 1.1em;">JMM 定义了单线程内必须遵循如下重排序规则：</p>
<table style="border-collapse: collapse; border-spacing: 0; margin-bottom: 20px;">
<thead>
<tr>
<th style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">NormalLoad</th>
<th align="center" style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">NormalStore</th>
<th align="center" style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">VolatileLoad / MonitorEnter</th>
<th align="center" style="padding: .5em; line-height: 1.5; vertical-align: bottom; border-top: 0; font-weight: bold; border: 1px solid #ddd;">VolatileStore / MonitorExit</th>
</tr>
</thead>
<tbody><tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NormalLoad</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
</tr>
<tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">NomalStore</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
</tr>
<tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">VolatileLoad / MonitorEnter</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">LoadLoad</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">LoadStore</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">LoadLoad</td>
</tr>
<tr>
<td style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;">VolatileStore / MonitorExit</td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"></td>
<td align="center" style="padding: .5em; line-height: 1.5; vertical-align: top; border-top: 1px solid #ddd; border: 1px solid #ddd;"><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code></td>
</tr>
</tbody></table>
<p style="margin: 0 0 1.1em;">看上去很复杂，但其实只有两点：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><p style="margin: 0 0 1.1em;"><em>* <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile</code> 变量 / <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Monitor</code>具有 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire &amp; Write-Release</code> 语义； *</em></p>
<p style="margin: 0 0 1.1em;">第三行即 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code>，最后一列即 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code>；</p></li>
<li><p style="margin: 0 0 1.1em;"><em>* 在任意两个 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile</code> 变量 / <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Monitor</code> 的 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Store-&gt;Load</code> / <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Exit-&gt;Enter</code> 操作中间必须插入一个 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code> barrier 禁止重排序; 这同时也解决了单个 volatile 变量 / Monitor 可能出现的可见性问题 。*</em></p>
<p style="margin: 0 0 1.1em;">可见性问题已经在3.3描述过了.</p></li>
</ol>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1403963190097.png" name="b09cfb74-f1f3-43c7-9cd4-589f12e443f9" src="/assets/img/76c4cf48eb5fc3fc8f6dde0593ee85ef.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">JMM cookbook 中提到了一种可能的实现。编译器很多时候无法知道确切的<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Load</code> / <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Store</code> 指令顺序，比如在一个方法 return 之前对一个 Volatile 变量 write 了，因此一个策略是采取悲观策略，在每个可能需要禁止某种重排序的地方都加上对应的 barrier：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>在每个 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile Read / Monitor Enter</code> 后加上 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadLoad</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadStore</code> barrier，亦即 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Read-Acquire</code> barrier;</li>
<li>在每个 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile Write / Monitor Exit</code> 前加上 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreStore</code> &amp; <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">LoadStore</code> barrier，亦即 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Write-Release</code> barrier;</li>
<li>在每个 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile Write / Monitor Exit</code> 后加上 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code> barrier（也可以在每次 Read 前加上，但 Write 出现的几率显然要低的多）。</li>
</ol>
<p style="margin: 0 0 1.1em;">当然，编译器会做许多别的优化，比如合并 barrier 之类的，而且很大一部分的 barrier 对应到硬件指令时是空操作。</p>
<p style="margin: 0 0 1.1em;">这个策略在 openjdk 的 C1 编译器<a href="https://www.evernote.com/OutboundRedirect.action?dest=https%3A%2F%2Fcode.google.com%2Fp%2Fneedle%2Fsource%2Fbrowse%2Fsrc%2Fshare%2Fvm%2Fc1%2Fc1_LIRGenerator.cpp%3Fr%3D2f644f85485d7460dea5edb5f6c8716093e66a44" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank"> (c1_LIRGenerator.cpp) </a>中得到了印证：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #75715e;">//------------------------field access--------------------------------------</span>

<span style="color: #75715e;">// Comment copied form templateTable_i486.cpp</span>
<span style="color: #75715e;">// ----------------------------------------------------------------------------</span>
<span style="color: #75715e;">// Volatile variables demand their effects be made known to all CPU's in</span>
<span style="color: #75715e;">// order.  Store buffers on most chips allow reads &amp; writes to reorder; the</span>
<span style="color: #75715e;">// JMM's ReadAfterWrite.java test fails in -Xint mode without some kind of</span>
<span style="color: #75715e;">// memory barrier (i.e., it's not sufficient that the interpreter does not</span>
<span style="color: #75715e;">// reorder volatile references, the hardware also must not reorder them).</span>
<span style="color: #75715e;">//</span>
<span style="color: #75715e;">// According to the new Java Memory Model (JMM):</span>
<span style="color: #75715e;">// (1) All volatiles are serialized wrt to each other.</span>
<span style="color: #75715e;">// ALSO reads &amp; writes act as aquire &amp; release, so:</span>
<span style="color: #75715e;">// (2) A read cannot let unrelated NON-volatile memory refs that happen after</span>
<span style="color: #75715e;">// the read float up to before the read.  It's OK for non-volatile memory refs</span>
<span style="color: #75715e;">// that happen before the volatile read to float down below it.</span>
<span style="color: #75715e;">// (3) Similar a volatile write cannot let unrelated NON-volatile memory refs</span>
<span style="color: #75715e;">// that happen BEFORE the write float down to after the write.  It's OK for</span>
<span style="color: #75715e;">// non-volatile memory refs that happen after the volatile write to float up</span>
<span style="color: #75715e;">// before it.</span>
<span style="color: #75715e;">//</span>
<span style="color: #75715e;">// We only put in barriers around volatile refs (they are expensive), not</span>
<span style="color: #75715e;">// _between_ memory refs (that would require us to track the flavor of the</span>
<span style="color: #75715e;">// previous memory refs).  Requirements (2) and (3) require some barriers</span>
<span style="color: #75715e;">// before volatile stores and after volatile loads.  These nearly cover</span>
<span style="color: #75715e;">// requirement (1) but miss the volatile-store-volatile-load case.  This final</span>
<span style="color: #75715e;">// case is placed after volatile-stores although it could just as well go</span>
<span style="color: #75715e;">// before volatile-loads.</span>

<span style="color: #75715e;">// volatile store</span>
<span style="color: #ae81ff;">void</span> LIRGenerator<span style="color: #f8f8f2;">::do_StoreField</span>(StoreField<span style="color: #e6db74;">*</span> x) {
    <span style="color: #75715e;">// Write-Release barrier</span>
    <span style="color: #f92672;">if</span> (is_volatile <span style="color: #e6db74;">&amp;&amp;</span> os<span style="color: #f8f8f2;">::is_MP</span>()) {
        __ membar_release();
    }

    <span style="color: #75715e;">// Store</span>
    <span style="color: #f92672;">...</span>
    volatile_field_store(value<span style="color: #e6db74;">.</span>result(), address, info);
    <span style="color: #f92672;">...</span>

    <span style="color: #75715e;">// StoreLoad barrier，这里直接写作 membar 的原因是大部分平台上 storeload barrier 被实现为一个 full barrier</span>
    <span style="color: #f92672;">if</span> (is_volatile <span style="color: #e6db74;">&amp;&amp;</span> os<span style="color: #f8f8f2;">::is_MP</span>()) {
        __ membar();
    }
}

<span style="color: #75715e;">// volatile load</span>
<span style="color: #ae81ff;">void</span> LIRGenerator<span style="color: #f8f8f2;">::do_LoadField</span>(LoadField<span style="color: #e6db74;">*</span> x) {
    <span style="color: #75715e;">// Load</span>
    <span style="color: #f92672;">...</span>
    volatile_field_load(address, reg, info);
    <span style="color: #f92672;">...</span>

    <span style="color: #75715e;">// Read-Acquire barrier</span>
    <span style="color: #f92672;">if</span> (is_volatile <span style="color: #e6db74;">&amp;&amp;</span> os<span style="color: #f8f8f2;">::is_MP</span>()) {
        __ membar_acquire();
    }
}
</code></pre>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">3. JMM的其他方面</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><strong style="font-weight: bold;">原子性</strong>，JMM 规定基本类型的 load/store 必须是原子的；</li>
<li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Volatile</code> 变量不允许使用寄存器分配。</li>
<li>final 变量??</li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">4. 总结</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">volatile</code>的作用：<strong style="font-weight: bold;">保证线程A的内存操作被线程B观察时，是有序的</strong>。单线程内，编译器、CPU会出于各种原因乱序<em>完成</em>指令，虽然本线程内的逻辑依然是正确的，但外部线程观察到的指令生效的顺序不可保证，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">volatile</code>就是解决这个问题的。</li>
<li>什么时候用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">volatile</code>? –  当一个变量被多线程访问, 且会被其中某些线程 write 时, 用<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">volatile</code>.</li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">5. 参考资料</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">The JSR-133 Cookbook</a></li>
<li>何登成的《CPU Cache and Memory Ordering.ppt》</li>
<li><a href="http://docs.google.com/presentation/d/1JkOUQ07nr0WQ8SKqcWA5D3M0v1gUdAwgNBbUcMhhGis/preview?usp=sharing&amp;sle=true#slide=id.p" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">无锁化编程</a></li>
<li><a href="http://preshing.com/20120913/acquire-and-release-semantics" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Acquire and Release Semantics</a></li>
<li><a href="http://preshing.com/20120625/memory-ordering-at-compile-time/" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Memory Ordering at Compile Time</a></li>
<li><a href="http://ifeve.com/memory-barriersfences/" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Memory Barriers/Fences</a></li>
<li><a href="http://gvsmirnov.ru/blog/tech/2014/02/10/jmm-under-the-hood.html#printassembly-fun" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Java Memory Model Under The Hood</a></li>
<li><a href="http://www.linuxjournal.com/article/8212" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Memory Ordering in Modern Microprocessors, Part II</a></li>
<li><a href="http://ifeve.com/cpu-cache-flushing-fallacy-cn/" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">CPU Cache Flushing Fallacy</a></li>
<li><a href="http://preshing.com/20120930/weak-vs-strong-memory-models/" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Weak vs. Strong Memory Models</a></li>
<li><a href="http://www.infoq.c/java-memory-model-1" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">深入理解Java内存模型</a> 系列文章</li>
</ol>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; margin-top: 21px; margin-bottom: 21px; border: 0; border-top: 1px solid rgba(102,128,153,0.1); margin: 2em 0;"/>
<p style="margin: 0 0 1.1em;">附：<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">StoreLoad</code> 乱序导致 <code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">Peterson 算法</code> 失效 <br/>
这不属于通用问题，而是依赖代码的逻辑。</p></div><div></div></div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html&text=Java内存模型和Volatile" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html&title=Java内存模型和Volatile" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->
<!-- 
      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">目录</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div> -->
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>
    <button id="js-toc"><span id="icon-list" class="fa fa-list-ul"></span></button>
    <div id="post__toc">
      <span id="post__toc-title">目录</span>
      <ul id="post__toc-ul"></ul>
    </div>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
