<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>Hash & Rabin-Karp字符串查找算法</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">jvm<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label8" class="tags__li tags-btn">网络<span class="post_count"></span></li>
          <li id="js-label9" class="tags__li tags-btn">工作<span class="post_count"></span></li>
          <li id="js-label10" class="tags__li tags-btn">设计<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2015/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B8%A9%E7%9A%84%E5%87%A0%E4%B8%AA(%E5%B8%B8%E8%AF%86)%E5%9D%91.html"><span class="pl__circle"></span><span class="pl__title">消息中心开发过程中踩的几个(常识)坑</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/08/17/%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">异常</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/08/17/Restful%20API%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83.html"><span class="pl__circle"></span><span class="pl__title">Restful API 的设计规范</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/InnoDB%20%E9%94%81.html"><span class="pl__circle"></span><span class="pl__title">InnoDB 锁</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/INSERT%20ON%20DUPLICATE%20KEY%20UPDATE%20%E5%87%A0%E4%B8%AA%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">INSERT ON DUPLICATE KEY UPDATE 几个要注意的问题</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2015/05/05/GIT%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html"><span class="pl__circle"></span><span class="pl__title">GIT常用操作</span><span class="pl__date">May 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/04/02/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">常用设计模式的总结</span><span class="pl__date">Apr 2015</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/09/11/ThreadLocal%20%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">ThreadLocal 分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/04/MapReduce%20Algorithms.html"><span class="pl__circle"></span><span class="pl__title">MapReduce Algorithms</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/09/03/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Skyline监控系统工作原理分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%20timeseries%E5%BC%82%E5%B8%B8%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Skyline timeseries异常判定算法</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">排序总结</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"><span class="pl__circle"></span><span class="pl__title">快速排序</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">几个常见的概率问题</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/31/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html"><span class="pl__circle"></span><span class="pl__title">常见的HTTP状态码</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/28/BloomFilter.html"><span class="pl__circle"></span><span class="pl__title">BloomFilter</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="jvm pl__all" href="/jvm/2014/07/27/gc.html"><span class="pl__circle"></span><span class="pl__title">JVM GC调优</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">二叉树的各种遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">JDK 中的并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型和Volatile</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C及虚拟内存总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache & False Sharing & 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">Hash & Rabin-Karp字符串查找算法</h1>
  <div style="line-height: 1.5; color: #2c3f51;">
<div></div>
<div>
</div><div>

<p style="margin: 0 0 1.1em;"></p>
<div><div><div>
<ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">Hash &amp; Rabin-Karp字符串查找算法</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">1. Hash函数</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">正整数</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">字符串</a></li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">2. Java的hashCode()</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">3. 碰撞</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">4. Rabin-Karp子字符串查找算法</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">5. 二维扩展</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">6. 参考资料</a></li>
</ul>
</div>
</div>
</div></div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">1. Hash函数</h1>
<p style="margin: 0 0 1.1em;">将若干元素均匀的映射到一个空间（大小为M）的各个位置，常用于快速查找。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">正整数</h2>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">最常用的函数：“%”, `hash = <span style="color: #f8f8f2;">key</span> % M`

M一般是素数，否则可能无法利用<span style="color: #f8f8f2;">key</span>中包含的所有信息。如<span style="color: #f8f8f2;">key</span>是十进制数而M是<span style="color: #ae81ff;">10</span>的k次方，那么只能利用<span style="color: #f8f8f2;">key</span>的后K位，不均匀，增加碰撞概率。
</code></pre>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">字符串</h2>
<p style="margin: 0 0 1.1em;">%也适用于字符串，只需要将字符串看成一个若干位R进制的整数，不同的是R并不一定非得大于字符集的个数，可以适当进行调整，常常选取质数。</p>
<p style="margin: 0 0 1.1em;">代码：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #f92672;"><span style="color: #66d9ef;">public</span> <span style="color: #66d9ef;">int</span> <span style="color: #a6e22e;">hash</span><span style="color: #f8f8f2;">(String s,<span style="color: #66d9ef;">int</span> M)</span></span>{
    <span style="color: #f92672;">int</span> hash = <span style="color: #ae81ff;">0</span>;
    <span style="color: #f92672;">int</span> R = <span style="color: #ae81ff;">101</span>;    <span style="color: #75715e;">//进制</span>
    <span style="color: #75715e;">/*
        Horner's rule:
        hash(abc)=a*R^2 + b*R^1 + c*R^0 = ((a*R + b) * R) + c

    */</span>
    <span style="color: #f92672;">for</span>(<span style="color: #f92672;">int</span> i=<span style="color: #ae81ff;">0</span>;i&lt;s.length();i++){
        hash = R * hash + s.charAt(i);
    }
    <span style="color: #f92672;">return</span> hash % M;
}</code></pre>
<p style="margin: 0 0 1.1em;">这种计算方式当charAt方法返回的值过大或R太大时可能造成溢出，可以将第10行换成：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">hash = (R * hash + s.charAt(i)) % M;</code></pre>
<p style="margin: 0 0 1.1em;">这利用了%运算的基本性质，对于两个正整数a、b，有：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">(a+b)%n = (a%n + b%n) %n;
(a-b)%n = (a%n - b%n + n) %n;
(a*b)%n = (a%n * b%n) %n;</code></pre>
<p style="margin: 0 0 1.1em;">注意，在减法中，由于a%n 可能小于b%n，需要在结果上加上n。对于以上规则，a和b不需要同时%n，可以随意选取一方%n性质也成立。</p>
</div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">2. Java的hashCode()</h1>
<p style="margin: 0 0 1.1em;">将每个对象映射到Integer空间（因为返回值是int），由hashCode的调用方决定是否需要进一步映射到一个更小的空间，比如在HashSet这种场景。</p>
<p style="margin: 0 0 1.1em;">JDK为String类的hashCode提供了默认的实现：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">/<span style="color: #f92672;">*</span><span style="color: #f92672;">*</span>
 <span style="color: #f92672;">*</span> Returns a hash code for this string. The hash code for a
 <span style="color: #f92672;">*</span> <span style="color: #f8f8f2;">&lt;code&gt;</span>String<span style="color: #f8f8f2;">&lt;/code&gt;</span> object is computed as
 <span style="color: #f92672;">*</span> <span style="color: #f8f8f2;">&lt;blockquote&gt;</span><span style="color: #f8f8f2;">&lt;pre&gt;</span>
 <span style="color: #f92672;">*</span> s[0]<span style="color: #f92672;">*</span>31^(n-1) + s[1]<span style="color: #f92672;">*</span>31^(n-2) + ... + s[n-1]
 <span style="color: #f92672;">*</span> <span style="color: #f8f8f2;">&lt;/pre&gt;</span><span style="color: #f8f8f2;">&lt;/blockquote&gt;</span>
 <span style="color: #f92672;">*</span> using <span style="color: #f8f8f2;">&lt;code&gt;</span>int<span style="color: #f8f8f2;">&lt;/code&gt;</span> arithmetic, where <span style="color: #f8f8f2;">&lt;code&gt;</span>s[i]<span style="color: #f8f8f2;">&lt;/code&gt;</span> is the
 <span style="color: #f92672;">*</span> <span style="color: #f8f8f2;">&lt;i&gt;</span>i<span style="color: #f8f8f2;">&lt;/i&gt;</span>th character of the string, <span style="color: #f8f8f2;">&lt;code&gt;</span>n<span style="color: #f8f8f2;">&lt;/code&gt;</span> is the length of
 <span style="color: #f92672;">*</span> the string, and <span style="color: #f8f8f2;">&lt;code&gt;</span>^<span style="color: #f8f8f2;">&lt;/code&gt;</span> indicates exponentiation.
 <span style="color: #f92672;">*</span> (The hash value of the empty string is zero.)
 <span style="color: #f92672;">*</span>
 <span style="color: #f92672;">*</span> <span style="color: #75715e;">@return  a hash code value for this object.</span>
 <span style="color: #f92672;">*</span>/
public int hashCode() {
int h = hash;
if (h == 0) {
    int off = offset;
    char val[] = value;
    int len = count;

        for (int i = 0; i <span style="color: #f8f8f2;">&lt; len; i++) {
            h = 31*h + val[off++];
        }
        hash = h;
    }
    return h;
}</span></code></pre>
<p style="margin: 0 0 1.1em;">使用的算法和上面描述的一致，R选择的是31。</p>
<p style="margin: 0 0 1.1em;">具体的 HashMap 负责将 hashCode 映射到更小的空间，常用的方式是屏蔽符号位并取模：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #f92672;"><span style="color: #66d9ef;">int</span> <span style="color: #a6e22e;">hash</span><span style="color: #f8f8f2;">(Object x)</span></span>{
    <span style="color: #f92672;">return</span> (x.hashCode() &amp; <span style="color: #ae81ff;">0x7fffffff</span>) % M;
}</code></pre>
</div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">3. 碰撞</h1>
<p style="margin: 0 0 1.1em;">碰撞的常规解决办法有拉链法（链表数组）、开放定址法，这里不多做介绍。</p>
<p style="margin: 0 0 1.1em;">不需要存储元素，只需要比较、判重时，可以采用 ：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><p style="margin: 0 0 1.1em;"><strong style="font-weight: bold;">元素较少且比较随机时，使用一个巨大的映射空间（比如M=一个巨大的素数、直接MD5等等，空间不需保存不占内存），碰撞概率为1/M</strong>；</p>
<p style="margin: 0 0 1.1em;">碰撞的概率很低很低，相信概率的力量。</p></li>
<li><p style="margin: 0 0 1.1em;"><strong style="font-weight: bold;">元素很多时，进行k次hash，降低碰撞率</strong></p>
<p style="margin: 0 0 1.1em;">BloomFilter就是这么干的，加入的元素个数在某个阈值内时能保证错误率在可接受范围内，再多的话碰撞的概率就不行了。</p></li>
</ol>
</div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">4. Rabin-Karp子字符串查找算法</h1>
<p style="margin: 0 0 1.1em;">对于查找，第一反应就是hash，但是假设计算子串的hash为O(k)，遍历一遍原字符串计算每个子串的hash与pattern字符串的hash作比较，复杂度为O(n*k)，这和暴力比较是一样的。</p>
<p style="margin: 0 0 1.1em;">Rabin-Karp算法的关键思想是 某一子串的hash值可以根据上一子串的hash在常数时间内计算出来，这样比对的时间复杂度可以降为O(n-k)。Rabin-Karp对字符串的hash算法和上面描述的一样（按整数进制解析再求模），假设原字符串为s，H(i)表示第i个字符开始的k个子字符串的hash值，即 <br/>
<span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"><span><img class="en-media" height="18.375" longdesc="__SVG__a3b3f5a0ff6cd31ecdb5b179029fff8a" name="ea68ddab-8e6e-4aac-9138-0c79a097e6cc" src="/assets/img/003b4350a20067d079bb28c8c9914144" style="margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;" width="382.375"/></span></span></span>，（先不考虑%M），则 <span><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"><span><img class="en-media" height="18.375" longdesc="__SVG__1e04d5712a8b4cf111f7f0e620161137" name="55641ba6-3632-406c-a99b-1acc75e18c28" src="/assets/img/e322e54447ec197701f436a06970c810" style="margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;" width="295.75"/></span></span></span>，时间为常数。</p>
<p style="margin: 0 0 1.1em;">又由%的性质可得：</p>
</div><div>
<p style="margin: 0 0 1.1em;"></p><div><div style="text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;"><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"><span><img class="en-media" height="19.25" longdesc="__SVG__34a9b65243df0dbc3a0f4eeaa9d17f74" name="b126c50d-a941-490f-8cb1-567af716300e" src="/assets/img/b40a2119eeed66cef42c50ca3e85b2f4" style="margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;" width="366.625"/></span></span></div></div><p style="margin: 0 0 1.1em;"></p>
</div><div>
<p style="margin: 0 0 1.1em;"></p><div><div style="text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;"><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"><span><img class="en-media" height="19.25" longdesc="__SVG__30b65aa4ecb79b529ff5d689cf610cde" name="01120216-a7f7-41b4-aa20-67600f30bc6d" src="/assets/img/c9ff600fb7cc33cc140d973b7b885a86" style="margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;" width="341.25"/></span></span></div></div><p style="margin: 0 0 1.1em;"></p>
</div><div>
<p style="margin: 0 0 1.1em;"></p><div><div style="text-align: center; margin: 1em 0; position: relative; display: block; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%;"><span style="font-size: 100%; display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0; vertical-align: middle;"><span><img class="en-media" height="19.25" longdesc="__SVG__badac9170bf5ddb2e77a304be26fd107" name="ec2dd753-15bf-43f3-ac88-24ed2508fd5f" src="/assets/img/a517aef96ad9117c5a3e1bdda6ffe39c" style="margin-top: 0; margin-bottom: 0; border: 0; vertical-align: middle; max-width: 100%;" width="429.625"/></span></span></div></div><p style="margin: 0 0 1.1em;"></p>
<p style="margin: 0 0 1.1em;">即 i+1 处子串的 hash 可以由 i 处子串的 hash 直接计算而得，在中间结果 %M 主要是为了防止溢出。</p>
<p style="margin: 0 0 1.1em;">M 一般选取一个非常大的数字，子串的数目相对而言非常少，产生散列碰撞的概率为 1/M，可以忽略不计。</p>
<p style="margin: 0 0 1.1em;">代码实现如下，这里当hash一致时没有再回退检查。可以看到 Rabin-Karp 的瓶颈在于每个内循环都进行了乘和模运算，模运算是比较耗时的，而其他算法大部分只需要进行字符比对：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #f92672;">package</span> algorithm.string;

<span style="color: #f92672;">import</span> java.math.BigInteger;

<span style="color: #f92672;">public</span> class RabinKarp {

    <span style="color: #f92672;">private</span> <span style="color: #f92672;">static</span> <span style="color: #f92672;">long</span> M = <span style="color: #ae81ff;">1000000000000000003</span>L;   <span style="color: #75715e;">//集合空间大小，一个很大的素数</span>
    <span style="color: #f92672;">private</span> <span style="color: #f92672;">static</span> <span style="color: #e6db74;">int</span> R = <span style="color: #ae81ff;">31</span>;  <span style="color: #75715e;">//进制</span>
    {
        <span style="color: #75715e;">//M = BigInteger.valueOf((long) Math.pow(10, 18)).nextProbablePrime().longValue();</span>
    }

    <span style="color: #f92672;">private</span> <span style="color: #f92672;">long</span> patternHash;
    <span style="color: #f92672;">private</span> <span style="color: #f92672;">long</span> RK; <span style="color: #75715e;">// R^K % M，用于减去第一个数时的计算</span>
    <span style="color: #f92672;">private</span> <span style="color: #e6db74;">int</span> K; <span style="color: #75715e;">// 模式字符串的长度</span>

    <span style="color: #f92672;">public</span> RabinKarp(<span style="color: #f92672;">String</span> pattern) {
        patternHash = hash(pattern);
        K = pattern.length();

        <span style="color: #75715e;">// 计算RM</span>
        RK = <span style="color: #ae81ff;">1</span>;
        <span style="color: #f92672;">for</span> (<span style="color: #e6db74;">int</span> i = <span style="color: #ae81ff;">0</span>; i &lt; K; i++) {
            RK = (R * RK) % M;
        }
    }

    <span style="color: #f92672;">public</span> <span style="color: #e6db74;">int</span> search(<span style="color: #f92672;">String</span> txt) {
        <span style="color: #f92672;">long</span> substrHash = hash(txt, <span style="color: #ae81ff;">0</span>, K);
        <span style="color: #f92672;">if</span> (substrHash == patternHash) <span style="color: #f92672;">return</span> <span style="color: #ae81ff;">0</span>;    <span style="color: #75715e;">//一开始就匹配成功</span>
        <span style="color: #f92672;">for</span> (<span style="color: #e6db74;">int</span> i = <span style="color: #ae81ff;">1</span>; i + K &lt;= txt.length(); i++) {
            <span style="color: #75715e;">// H(i+1) % M = [H(i) % M * R + s[i+k] - s[i] * R^k % M + M] % M</span>
            substrHash = (substrHash * R  + txt.charAt(i + K - <span style="color: #ae81ff;">1</span>) - txt.charAt(i - <span style="color: #ae81ff;">1</span>) * RK % M  + M ) % M;
            <span style="color: #f92672;">if</span> (substrHash == patternHash)
                <span style="color: #f92672;">return</span> i;
        }
        <span style="color: #f92672;">return</span> -<span style="color: #ae81ff;">1</span>;
    }

    <span style="color: #75715e;">// Horner rule 计算字符串hash值</span>
    <span style="color: #f92672;">private</span> <span style="color: #f92672;">long</span> hash(<span style="color: #f92672;">String</span> <span style="color: #e6db74;">str</span>, <span style="color: #e6db74;">int</span> start, <span style="color: #e6db74;">int</span> length) {
        <span style="color: #f92672;">long</span> hash = <span style="color: #ae81ff;">0</span>;
        <span style="color: #f92672;">for</span> (<span style="color: #e6db74;">int</span> i = start; i &lt; length; i++) {
            hash = (hash * R + <span style="color: #e6db74;">str</span>.charAt(i)) % M;
        }
        <span style="color: #f92672;">return</span> hash;
    }

    <span style="color: #f92672;">private</span> <span style="color: #f92672;">long</span> hash(<span style="color: #f92672;">String</span> <span style="color: #e6db74;">str</span>) {
        <span style="color: #f92672;">return</span> hash(<span style="color: #e6db74;">str</span>, <span style="color: #ae81ff;">0</span>, <span style="color: #e6db74;">str</span>.length());
    }

    <span style="color: #f92672;">public</span> <span style="color: #f92672;">static</span> <span style="color: #f92672;">void</span> main(<span style="color: #f92672;">String</span>[] args) {
        <span style="color: #f92672;">String</span> pattern = <span style="color: #e6db74;">"y similar t"</span>;
        RabinKarp rk = <span style="color: #f92672;">new</span> RabinKarp(pattern);
        <span style="color: #f92672;">String</span> txt = <span style="color: #e6db74;">"Technically, this algorithm is only similar to the true number in a non-decimal"</span>;
        System.out.<span style="color: #e6db74;">println</span>(txt);
        <span style="color: #e6db74;">int</span> index = rk.search(txt);
        <span style="color: #f92672;">if</span> (index &gt;= <span style="color: #ae81ff;">0</span>) {
            <span style="color: #f92672;">for</span> (<span style="color: #e6db74;">int</span> i = <span style="color: #ae81ff;">0</span>; i &lt; index; i++) {
                System.out.<span style="color: #e6db74;">print</span>(<span style="color: #e6db74;">" "</span>);
            }
            System.out.<span style="color: #e6db74;">print</span>(pattern);
        }

    }
}</code></pre>
<p style="margin: 0 0 1.1em;">输出为：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">Technically, this algorithm is only similar <span style="color: #e6db74;">to</span> <span>the</span> <span style="color: #66d9ef;">true</span> <span style="color: #e6db74;">number</span> <span>in</span> <span>a</span> non-decimal
                                  y similar t</code></pre>
</div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">5. 二维扩展</h1>
<p style="margin: 0 0 1.1em;">Rabin-Karp 算法可以扩展到二维，可用于二维数组、图像的查找。基本思想如下：</p>
<blockquote style="padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;">
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">问题：在一个 n1*n2 的二维字符组成中搜寻一个给定的 m1*m2 的模式。</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">首先来看模式矩阵。如果把m2列中的每一列都看做一个整体，那么他们每一个都是一个一维的串，可以分别计算出hash值（使用霍纳法则），这样模式矩阵就成了一个一维的长度为m2的模式串。</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">然后，对大矩阵的前m1行，用同样的方法能得到一个长度为n2的串。</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">这样，在大矩阵的前m1行中寻找模式矩阵，就转化成了一维的字符串匹配问题。（这里使用一维的串匹配算法就能解决，比如KMP）</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;">最后，用同样的方法，在大矩阵的第2到第m1+1行，第3到m1+2行。。。都可以用同样的方法匹配。 <br/>
  这里的关键是，每次匹配时，转化后的一维串可以通过上次的串直接计算出来。（类似于Rabin-Karp由ts可以在常数时间内计算出ts+1）</p>
</blockquote>
<p style="margin: 0 0 1.1em;">可以想象成用一个m1*m2的窗口，在原矩阵上从左到右从上到下一格一格地比对。</p>
<p style="margin: 0 0 1.1em;">在水平移动时，将窗口和窗口所在的m1行中（原矩阵）的所有列都hash成一个数字，这样问题就变成了一维的查找，可以用kmp之类的算法解决。</p>
<p style="margin: 0 0 1.1em;">在垂直移动时，移动后窗口每列的hash值都能根据该列移动前的hash直接计算出来，Rabin-Karp一维时的规则此时依然适用。对于原矩阵也如法炮制，问题继续转换成一维的查找。</p>
<p style="margin: 0 0 1.1em;">因此在实现时，使用两个一维数组，一个保存窗口中每列的hash，一个保存原矩阵每列（高度为窗口的高度）的hash，方便垂直移动时hash的重新计算。</p>
<p style="margin: 0 0 1.1em;">代码TODO。</p>
</div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">6. 参考资料</h1>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><a href="http://book.douban.com/subject/4854123/" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">《Algorithms》</a></li>
<li><a href="http://ellard.org/dan/www/Courses/sq98_root.pdf" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">S-Q Course Book</a></li>
<li><a href="http://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Wiki</a></li>
<li><a href="http://www.strongczq.com/2012/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.html" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">基础算法专题二：字符串匹配</a></li>
<li><a href="http://blog.csdn.net/chocolate_22/article/details/6458029" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">关于同余与模运算的总结</a></li>
<li><a href="http://cs.bilgi.edu.tr/~sbakir/232/Rabin.pdf" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Rabin-Karp Method For Two Dimensional Arrays - Implementation in JAVA</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_6a09b5a70100nhnr.html" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">二维模式（矩阵）匹配（Rabin-Karp算法推广到二维）</a></li>
</ol></div><div></div></div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html&text=Hash & Rabin-Karp字符串查找算法" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html&title=Hash & Rabin-Karp字符串查找算法" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->
<!-- 
      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">目录</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div> -->
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>
    <button id="js-toc"><span id="icon-list" class="fa fa-list-ul"></span></button>
    <div id="post__toc">
      <span id="post__toc-title">目录</span>
      <ul id="post__toc-ul"></ul>
    </div>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
