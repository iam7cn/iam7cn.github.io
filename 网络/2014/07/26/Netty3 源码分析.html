<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>Netty3 源码分析</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">jvm<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label8" class="tags__li tags-btn">网络<span class="post_count"></span></li>
          <li id="js-label9" class="tags__li tags-btn">工作<span class="post_count"></span></li>
          <li id="js-label10" class="tags__li tags-btn">设计<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2015/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B8%A9%E7%9A%84%E5%87%A0%E4%B8%AA(%E5%B8%B8%E8%AF%86)%E5%9D%91.html"><span class="pl__circle"></span><span class="pl__title">消息中心开发过程中踩的几个(常识)坑</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/08/17/%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">异常</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/08/17/Restful%20API%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83.html"><span class="pl__circle"></span><span class="pl__title">Restful API 的设计规范</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/InnoDB%20%E9%94%81.html"><span class="pl__circle"></span><span class="pl__title">InnoDB 锁</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/INSERT%20ON%20DUPLICATE%20KEY%20UPDATE%20%E5%87%A0%E4%B8%AA%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">INSERT ON DUPLICATE KEY UPDATE 几个要注意的问题</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2015/05/05/GIT%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html"><span class="pl__circle"></span><span class="pl__title">GIT常用操作</span><span class="pl__date">May 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/04/02/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">常用设计模式的总结</span><span class="pl__date">Apr 2015</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/09/11/ThreadLocal%20%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">ThreadLocal 分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/04/MapReduce%20Algorithms.html"><span class="pl__circle"></span><span class="pl__title">MapReduce Algorithms</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/09/03/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Skyline监控系统工作原理分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%20timeseries%E5%BC%82%E5%B8%B8%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Skyline timeseries异常判定算法</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">排序总结</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"><span class="pl__circle"></span><span class="pl__title">快速排序</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">几个常见的概率问题</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/31/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html"><span class="pl__circle"></span><span class="pl__title">常见的HTTP状态码</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/28/BloomFilter.html"><span class="pl__circle"></span><span class="pl__title">BloomFilter</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="jvm pl__all" href="/jvm/2014/07/27/gc.html"><span class="pl__circle"></span><span class="pl__title">JVM GC调优</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">二叉树的各种遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">JDK 中的并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型和Volatile</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C及虚拟内存总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache & False Sharing & 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">Netty3 源码分析</h1>
  <div style="line-height: 1.5; color: #2c3f51;">
<div></div>
<div>
</div><div>

<div><div><div>
<ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">Netty3 源码分析</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">1. 总体结构</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">2. Netty的API</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">3. Channel</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">3.1 ServerChannel</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">ServerSocketChannel</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">LocalServerChannel</a></li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">3.2 SocketChannel</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">ClientSocketChannel</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">AcceptedSocketChannel</a></li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">3.3 LocalChannel</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">3.4 DatagramChannel</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">3.5 Channel的方法</a></li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">4. ChannelFactory</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">4.1 ServerChannelFactory</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">4.2 ClientSocketChannelFactory</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">4.3 LocalChannelFactory</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">4.4 DatagramChannelFactory</a></li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">5.ChannelPipeline</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">6. ChannelEvent</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">7. ChannelSink</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">TCP Client端</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">TCP Server端</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">UDP协议</a></li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">8. ChannelBuffer</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">ByteBufferBackedChannelBuffer</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">HeapChannelBuffer</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">DynamicChannelBuffer</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">复合Buffer：CompositeChannelBuffer</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">WrappedChannelBuffer</a></li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">9. ChannelBufferFactory</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">10. Reactor模式</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">11. Netty的NIO Server端实现</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<p style="margin: 0 0 1.1em;"></p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">1. 总体结构</h2>
<p style="margin: 0 0 1.1em;">Netty是Jboss旗下一款优秀的网络编程框架，作者是Trustin Lee，韩国人，80后。Netty简化了Java环境下的网络程序开发，它屏蔽了底层具体实现方式的差异和细节，为上层应用程序提供一个抽象的一致的接口。不管使用的传输层协议是TCP还是UDP，底层JDK API是NIO还是OIO，甚至是在同一JVM内部的通信，这些差异细节都被netty屏蔽在其内部，上层只需要跟netty提供的网络编程模型打交道，并指定要使用何种具体实现（这在netty内被称为transport service）即可，要切换时也非常方便。Netty的总体结构如下：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片1.png" name="22b19047-d397-4ad4-a4f2-944843f6bc24" src="/assets/img/309fe45c76960f7d6f11ee79091d69d3.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">这里再引用netty官方文档中的一段话：</p>
<blockquote style="padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;">
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;">“The Netty project is an effort to provide an asynchronous event-driven network application framework and tools for rapid development of maintainable high performance and high scalability protocol servers and clients. In other words, Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP/IP socket server.”</p>
</blockquote>
<p style="margin: 0 0 1.1em;">从这段话中我们可以看出Netty几个最主要的特性：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>异步编程模型</li>
<li>事件驱动</li>
<li>（主要基于）NIO实现</li>
</ol>
<p style="margin: 0 0 1.1em;">在本文后续对Netty源代码分析的过程中中会针对这三点进行详细的讲述。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">2. Netty的API</h2>
<p style="margin: 0 0 1.1em;">Netty自己引入了一套网络模型的抽象，要想深入Netty，首先要对这套API有较为深入的了解。以下是使用Netty编程时所接触的上层接口及它们的交互方式：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片2.png" name="ab5deea4-b644-43d3-a33b-5ca7b0630932" src="/assets/img/efdc5e17341f1ca352f3197a34ff6a90.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">处在整套模型的核心位置的是Channel，Channel通常是对底层Socket的抽象表示（在TCP实现中），但也可能是其他可以进行IO操作的数据源。可以把它想象成一个管道，应用程序可以打开一个管道，连接到某处（通常是另一个Channel），通过管道向目的地写数据，也可以从管道读另一端发送过来的数据，类似这样：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片3.png" name="6173695e-55a1-4dc9-98db-1a7533e70a37" src="/assets/img/b0305801a5ccbd5f43f91ed05d3df7db.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">之前说过Netty是事件驱动的，每个Channel都有一个ChannelPipeline，在Channel上发起的所有事件都会被送到ChannelPipeline中流转一遍得到处理。这些事件由ChannelEvent表示，按事件在ChannelPipeline中的流向又分为Upstream和Downstream两种事件。Pipeline中保存着一系列ChannelHandler，事件在这些Handler之间被处理并传递。同时，每个ChannelPipeline都会被指定一个ChannelSink，挂在Handler链的最末端，事件被所有Handler处理完成后最终会流向ChannelSink被其处理，这也是它为什么要“Sink(沉没)”的原因。关于Channel的事件及其流转这一整套体系还是比较复杂的，后面会详细讲到。</p>
<p style="margin: 0 0 1.1em;">Channel大部分情况下是由ChannelFactory生产的。每个ChannelFactory一般都会在内部创建一个ChanelSink，在生产Channel的时候，会负责将Pipeline、Channel、Sink这三者装配在一起，这意味着同一个ChannelFactory生产的Channel，它们的Pipeline虽然是不一样的，但ChannelSink却是公用一个，在后面的代码中我们也能发现这一点。</p>
<p style="margin: 0 0 1.1em;">在Channel上发起的所有IO操作都是“异步”的。“异步”这个词语很容易引起混淆，根据《Unix网络编程 卷一》一书所述，以输入为例，包含两个阶段：</p>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>数据从硬件底层传递到内核缓冲区；</li>
<li>从内核缓冲区向用户进程空间复制数据。</li>
</ul>
<p style="margin: 0 0 1.1em;">根据POSIX的定义，只要在以上两步中引起了用户进程的阻塞，这样的IO均称为同步IO，反之则称为异步IO。按照这样的定义，Unix下的5种IO模型：阻塞式IO、非阻塞IO、IO复用、信号驱动、异步IO，只有最后一种才能被称为是“异步IO模型”，并且Linux内核直到2.6版本才提供了AIO的支持。JDK在1.4之前的提供的IO库是面向流的阻塞式IO（Old IO），1.4开始引入的NIO（New IO）提供了非阻塞IO和IO复用（IO multiplexing），并不真正支持异步IO（JDK 7之前），我们经常可以在别人的文章中看到“NIO带来了异步IO”等等这样的说法，实际上都是错误的。</p>
<p style="margin: 0 0 1.1em;">回到本文，在Netty的语境下的“异步”，全名应该是“异步编程模型”或者“异步通知机制”，它的含义其实更接近于“非阻塞”，并且它也是基于NIO实现的。在Channel上调用的IO操作会立刻返回一个ChannelFuture对象而不保证在方法返回的时刻操作已经完成，后者保存着这个操作的执行状态，是成功还是失败，取消还是异常诸如此类。“异步”意味着调用线程不会由于IO操作而阻塞，但只能通过ChannelFuture跟踪操作的执行情况。</p>
<p style="margin: 0 0 1.1em;">这里可以简单地解释一下这套异步编程模型的具体实现，Channel上发起的IO请求，实际都会被转换成ChannelEvent事件（大部分是DownStream的）交由Pipeline最终到Sink获得处理，同时，每个ChannelEvent内部都有一个ChannelFuture对象保存着该事件的处理情况。Netty内部使用NIO的非阻塞方法进行实际的IO，实时更新相应的ChannelFuture并最终返回给调用者。举个例子，假如我们向Channel提交一个2M数据的写请求，事件经由Pipeline流转处理，最终Netty调用NIO在本次只写入了8K，则ChannelFuture被更新为“进行中，8K”类似的状态并返回。当下次Channel可写的时候再写入比如4K，并再次更新ChannelFuture，如此往复直到完成。这种“异步”的调用方式要求调用方通过为ChannelFuture添加监听回调的形式编程，对应的接口是ChannelFutureListener。相反，如果底层切换到阻塞式的OIO实现，则异步的特性就不复存在了，仍然举刚刚的例子：当Netty内部通过OIO向Channel写入2M数据时，会一直阻塞直到这2M数据全部写完才返回。</p>
<p style="margin: 0 0 1.1em;">最后， Channel通过ChannelConfig保存自身的配置信息，此外，ChannelConfig还保存着该Channel使用的ChannelBufferFactory和ChannelPipelineFactory。ChannelBufferFactory负责创建Channel在IO过程中使用的ChannelBuffer。Netty使用ChannelBuffer来存储并操作读写的网络数据，它有点像NIO中的ByteBuffer但比后者更优秀。ChannelPipelineFactory是创建ChannelPipeline的工厂，一般由用户指定。Netty提供了默认的Pipeline的实现，一般来说我们只需要往里面加Handler就可以了，通过Handler实现我们想要的逻辑，非常方便。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">3. Channel</h2>
<p style="margin: 0 0 1.1em;">从本节开始我们将深入探索Netty内部，详细了解Netty接口之下具体的实现，首先是Channel，以下是它整个产品体系的类图：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片4.png" name="b807173b-327c-4f32-9cd5-080ee25c8933" src="/assets/img/787f971b2c46fe51da347e2f126b7597.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">从图中可以看到，Channel产品族非常清晰的划分成4大种类：</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.1 ServerChannel</h3>
<p style="margin: 0 0 1.1em;">所有的网络程序都分为服务器端和客户端， 在使用基于连接的通信协议时，Netty在服务器端遵循这样的抽象模型：使用一个listening channel（Netty内部称之为Server-side channel，这里就用listening channel这个说法，个人感觉更贴切一些）不停地监听客户端发起的连接，每当接受了一个连接请求后就创建一个accepted channel用于后续实际和客户端的网络通信。该抽象模型其实和JDK提供的OIO（java.net.ServerSocket和java.net.Socket）、NIO（java.nio.channels.ServerSocketChannel和java.nio.channels.SocketChannel）编程模型是一致的。</p>
<p style="margin: 0 0 1.1em;">ServerChannel代表的就是上述模型中的listening channel，它一般只由ServerChannelFactory创建，且自身又被细化成两个产品族：</p>
</div><div>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;">ServerSocketChannel</h4>
<p style="margin: 0 0 1.1em;">使用TCP协议时，服务器端的listening channel。接口名称中的“Socket“指的是底层使用伯克利套接字进行TCP通信。它有OIO和NIO两套实现，分别是java.net.ServerSocket和java.nio.channels.SocketChannel的包装。 <br/>
该种类型的Channel在接收连接后会生产出SocketChannel，这对应于Channel另一个子产品体系，稍后会详细谈到。</p>
</div><div>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;">LocalServerChannel</h4>
<p style="margin: 0 0 1.1em;">通过In-VM通信的网络程序使用与其他依赖真实网络进行通信的程序一样的API，但实际的数据交换过程却是发生在同一个JVM中的，并且也使用上述的网络模型。LocalServerChannel是这种情况下服务器端的listening channel，只由一个默认实现。在本次分析源码的过程中没有太多了解。它在接受连接后生产LocalChannel，也是Channel的另一子产品族。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.2 SocketChannel</h3>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片6.png" name="d3435a30-9def-4a9a-a22b-3200b7104ac5" src="/assets/img/7527f31b9cdda05934e2d1edd944ebc9.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">SocketChannel代表底层使用TCP/IP套接字通信的 <strong style="font-weight: bold;">非Server-side</strong> Channel。 <br/>
这个产品族分成两种角色，这也体现在名字上：</p>
</div><div>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;">ClientSocketChannel</h4>
<p style="margin: 0 0 1.1em;">在使用TCP协议通信的Client端生成的Channel，这类Channel一般只由ClientSocketChannelFactory创建：</p>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li><strong style="font-weight: bold;">NioClientSocketChannel</strong> <br/>
使用NIO方式的客户端Channel</li>
<li><strong style="font-weight: bold;">OioClientSocketChannel</strong> <br/>
使用OIO方式的客户端Channel</li>
<li><strong style="font-weight: bold;">HttpTunnelingClientSocketChannel</strong> <br/>
这里要提到一种“HTTP tunnel “技术。Http隧道是为了突破防火墙的限制，它和Http协议一样使用80端口通信。HttpTunnelingClientSocketChannel在客户端与Server端的HttpTunnelingServlet进行通信。在服务器端可以将基于Netty的真正的Server应用绑定到HttpTunnelingServlet指定的endpoint上（二者必须要在同一个JVM中），当HttpTunnelingServlet在收到客户端请求时会将该请求转发过去，相当于做了一次代理的工作，反之亦然。这个过程也涉及到In-VM形式的通信，会用到Local transport service相关的类。在本文中对该主题不做深入展开。</li>
</ul>
</div><div>
<h4 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 10.5px; margin-bottom: 10.5px; font-size: 1.25em; margin: 1.2em 0; text-align: start;">AcceptedSocketChannel</h4>
<p style="margin: 0 0 1.1em;">上文我们提到了使用TCP协议时Netty在服务器端使用的模型：Listening Channel和Accepted Channel，前者对应ServerSocketChannel，后者则是这里的** AcceptedSocketChannel来表示。注意，这类Channel没有对应的ChannelFactory，而是由Listening Channel负责创建。类似的，也有NIO和OIO两种实现方式（上图中绿色的两个类）： <br/>
NioServerSocketChannel — NioAcceptedSocketChannel <br/>
OioServerSocketChannel — OioAcceptedSocketChannel</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.3 LocalChannel</h3>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片7.png" name="71b2bb45-4c2c-4917-bfcb-66edeb7ba43e" src="/assets/img/fe1f825e87d8dd861ebc71b9f0f4aad6.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">正如在介绍LocalServerChannel时介绍的，它最终创建的Accepted Channel即为LocalChannel，亦仅有一个默认实现。</p>
<p style="margin: 0 0 1.1em;">但同时，LocalChannel也充当着”LocalClientChannel”的角色在Client端被使用。Netty没有区分这二者，而是让LocalChannel承担这两个角色。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.4 DatagramChannel</h3>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片8.png" name="ad452f7c-66db-4335-8186-8ef7ad9ed132" src="/assets/img/1750106f09ec106147b5e84d274b62e5.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">DatagramChannel代表了底层使用UDP协议通信的Channel，它只由DatagramChannelFactory创建。 <br/>
同样的，底层也有NIO和OIO两种实现。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">3.5 Channel的方法</h3>
<p style="margin: 0 0 1.1em;">Channel的方法分为两种：</p>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>同步的getter，查看Channel的各种状态；</li>
<li>异步的IO方法如connect、bind、write等，仔细查看代码可以发现没有open和read方法，这是因为一个Channel被创建出来时就会默认被打开；并且应用程序一般不会主动向Channel发起read，而是由Netty内部在有数据到达时生成ChannelEvent在pipeline中向上传递。</li>
</ul>
<p style="margin: 0 0 1.1em;">Channel是有父子关系的，典型的，Server端的ListeningChannel和Accepted Channel就是父子关系，因为前者间接地导致后者的创建。</p>
<p style="margin: 0 0 1.1em;">综上所述，Channel根据底层使用的协议（TCP/UDP）、角色（Server端的Listening Channel和Accepted Channel，Client端的Channel）、使用何种JDK IO类库实现（NIO/OIO）等特性被逐层细分为几大子产品体系，从上而下逐渐由抽象到具体。再看该套体系的实现，相似产品的相同逻辑被大量抽取到抽象类中，每个具体实现一方面实现自身特殊的接口，一方面继承该抽象类获得对通用接口的实现，在自己代码中只需实现少量扩展方法，通过这种方式做到了最大程度的逻辑重用，典型的例子有AbstractChannel抽象类及其子类。这种“接口继承体系 + 默认抽象实现类“实现一套多层次的产品体系的模式在其他场景也是非常常见的。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">4. ChannelFactory</h2>
<p style="margin: 0 0 1.1em;">顾名思义，ChannelFactory主要的职责即负责创建各种各样的Channel，这也不难理解为什么ChannelFactory和Channel体系几乎有完全一样的结构了，它的类图和整个产品体系如下：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片9.png" name="b24abd4c-3252-451b-819c-876a800e9535" src="/assets/img/bf998ba2064084d8dde5428a5bd12b47.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/> <br/>
<img alt="Alt text" class="en-media" longdesc="./图片10.png" name="afdc4b80-46fc-44c3-87ed-f74a6bf0c239" src="/assets/img/fd2b48aa4eef5e008d2894068f60d772.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">ChannelFactory接口只有两个方法，其中方法newChannel负责创建Channel，并将指定的Pipeline绑定到该Channel。实际的实现常常在这一步还会完成pipeline和ChannelSink的绑定。 <br/>
同样的，ChannelFactory也分为4种：</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">4.1 ServerChannelFactory</h3>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片11.png" name="31faa382-ddb5-4e21-8eca-413f22cb1d09" src="/assets/img/2880ced072fc9ca859e77a9bf146ea00.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">ServerChannelFactory负责创建服务器端的listening channel，即以ServerChannel接口开始的一系列产品。它的继承体系和ServerChannel的体系是一一对应的，分为ServerSocketChannelFactory和LocalServerChannelFactory，前者又有NIO和OIO两种实现方式。这里不再赘述。 <br/>
需要注意的是，ServerChannelFactory并不负责创建Accepted Channel。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">4.2 ClientSocketChannelFactory</h3>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片12.png" name="2140b670-3ada-4dfa-ab9a-10c2e1d716f8" src="/assets/img/ac81abf9984dc8d679d2a35aaece2f1e.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">ClientSocketChannelFactory负责创建SocketChannel中的**ClientSocketChannel，它的继承体系和SocketChannel中Client-Side SocketCHannel是一致的，这里也没太多花招。 <br/>
上面说过，SocketChannel的另外一种角色是在TCP服务器端的Accepted Channel，这种Channel不是由工厂创建出来的，在ChannelFactory产品族中没有对应的工厂类。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">4.3 LocalChannelFactory</h3>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片13.png" name="5956ad94-7be1-4e79-8c5c-56a6a1f39212" src="/assets/img/6631417bd651ae7be5f4e8c99c167756.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">LocalChannelFactory负责创建LocalChannel，值得一提的是， LocalChannel同时承担Server端Accepted Channel和Client Channel的角色，这里的工厂仅负责创建后者。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">4.4 DatagramChannelFactory</h3>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片14.png" name="8c956bbf-03cb-41ae-b59b-a5965ad96e8b" src="/assets/img/b689844eba88b1f09354cbade4fb69c6.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">UDP相关的Channel的工厂类，没怎么深入过。</p>
<p style="margin: 0 0 1.1em;">ChannelFactory除了负责扮演工厂的角色，也同时是资源管理者，方法releaseExternalResources释放工厂外部资源。所有不是工厂自己创建的资源都属于“外部资源“，典型的如在构造器中为工厂指定的线程池等等。当要关闭ChannelFactory时，必须先关闭它所创建的所有Channel（通过ChannelGroup#close()进行批处理），其次调用releaseExternalResources方法释放所有外部资源。 <br/>
最后以一张Channel和ChannelFactory产品体系及它们之间的对应关系的图作为总结：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片15.png" name="ec1c2c30-d279-4cd0-864a-ad5c396c5250" src="/assets/img/2c294a1a1a85db24a3f1e7d74f233b3b.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">5.ChannelPipeline</h2>
<p style="margin: 0 0 1.1em;">一旦Channel被创建出来，其ChannelPipeline就准备开始接受事件处理了。ChannelPipeline实现了Intercepting Filter模式，内部是一系列的ChannelHandler，Handler控制事件的处理、传递。 <br/>
Pipeline通常通过用户自己实现的ChannelPipelineFactory创建，Netty内部提供了Pipeline的一个默认实现：DefaultChannelPipeline，通常情况下这已经满足我们的需求了。通过Channels工具类的pipeline()静态方法可以得到一个空的DefaultChannelPipeline实例，我们只需往里面添加自定义的Handler就可以了。</p>
<p style="margin: 0 0 1.1em;">ChannelEvent在Pipeline中按照流向被分为UpStream和DownStream两种类型，Handler被分为相应的两种类型。PipeLine在Downstream或者Upstream类型的网络事件发生时，会从某一端开始调用匹配事件类型的Handler响应这种调用。ChannelPipeline维持有所有handler有序链表，并且由handler自身控制是否继续流转到下一个handler(通过ChannelHandlerContext#sendDownstream(e),这样设计有个好处就是随时终止流转，业务目的达到无需继续流转到下一个handler)。 <br/>
Pipeline中事件的流转如下图所示（摘自Netty的API文档）：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片16.png" name="b470a067-77b4-4b73-9080-5cfffc87e44c" src="/assets/img/3a81b965a390b83e0e0e3deb77bfc65a.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">UpStream事件由Netty内部的IO线程发起，通常是Netty内部完成某些IO操作之后，或有数据可读时主动反馈给Channel。Upstream事件由Pipeline低端开始，往上依次流经各UpstreamHandler，如果事件被传递出Handler链最顶端，则事件被忽略。</p>
<p style="margin: 0 0 1.1em;">Downstream事件是Channel向Netty内部提交的IO操作请求，比如关闭、绑定、写数据请求等等。Channel接口的IO方法，其实质是通过Channels工具类的fireXXXEvent触发事件机制。在Downstream Handler的最末端其实还挂接着一个ChannelSink（图中没有画出），所有Downstream事件在走完Handler链后都会进入这个ChannelSink中得到处理，并最终由Netty内部IO线程进行处理。这里有一个小的trik：对Channel真正的IO操作必须要由Netty内部的IO线程执行，如果是用户线程提交Downstream事件，最终会被加入IO线程池的任务队列，等待后者循环执行而非立刻执行。这个说法其实不太准确，但大概的原理是这样的，关于这一点后面还在进行源代码分析时还会详细介绍。</p>
<p style="margin: 0 0 1.1em;">为了对Pipeline的工作原理有个更直观的理解，我们来看看Netty提供的默认实现DefaultChannelPipeline，它的类图如下图所示：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片17.png" name="b471ebe4-c3d7-47fd-8e27-769b6c995255" src="/assets/img/4c7adc4aa1ddd7619d80b73dfbd2eacc.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">Netty还提供了另一个实现StaticChannelPipeline，这是一个不可变的pipeline。一旦创建之后，任何对他的添加删除Handler操作都会抛出异常。它的性能更加优异。</p>
<p style="margin: 0 0 1.1em;">属性channel和sink保存pipeline被绑定到的Channel和ChannelSink，name2ctx是内部维护的一个 Handler名 – DefaultChannelHandlerContext对象 的Map，便于快速通过名称查找。</p>
<p style="margin: 0 0 1.1em;">DefaultChannelPipeline在内部维护着一个DefaultChannelContext类型（是的，不是ChannelHandler而是它的Context）的双向链表，属性Head和Tail是它的首尾。ChannelContext是Handler的包装器，Handler可以通过它的Context将事件向下或向上传递，或者得到Pipeline对其进行修改。Context还为Handler提供了Attachment能力让其可以在几次被调用期间存储一些stateful信息。DefaultChannelContext是DefaultChannelPipeline的内部类，它是ChannelContext的默认实现，在Netty的pipeline默认实现中使用的都是这个类。</p>
<p style="margin: 0 0 1.1em;">虽然在ChannelPipeline的文档中画的图中显示，upstream和downstream事件的流向是分开的，但实际上内部只有一个Handler链而非两个。调用addLast(handler)等方法向其中添加Handler，经过几次后链表可能是这样： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片18.png" name="310d3748-94db-4d79-b628-777eeaf91c1d" src="/assets/img/8ffd6480e5a354b2054cd8e847721515.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">当调用sendUpstream（ChannelEvent  e）向pipeline中丢进去一个upstream类型的事件时，首先调用getActualUpstreamContext(this.head)从Head开始向后找到第一个Upstream类型的Handler（实际上是找它的Context，毕竟链表中的元素都是HandlerContext），将event交给它处理，该Handler很有可能在执行完逻辑后调用其context的sendUpstream(event)方法将事件继续向上传递，后者继续调用getActualUpstreamContext从自己出发找下一个Upstream Handler，整个Upstream事件的传递流程就像这样： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片19.png" name="bbb34dea-afdb-461b-bbfd-b9c0ac5acb48" src="/assets/img/dfa2667427a22fdd26df08edaf99f298.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">如果是Downstream类型的事件，整个处理流程与上面相反，是从Tail开始往前的，并且还有一个不同点，当最后一个Downstream Handler将事件继续向下传递时，事件最终会汇聚到挂在pipeline最下端的ChannelSink，被它的eventSunk方法处理。这个步骤是在DefaultChannelHandlerContext#sendDownstream（ChannelEvent）中实现的。如果没有为pipeline指定sink，则使用一个默认的实现DiscardingChannelSink，这个实现只调用logger记录一下，什么也不干。Downstream事件的流向如下图所示： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片20.png" name="1f5fb9ce-df50-478f-9216-4a8ec8f55f9a" src="/assets/img/8f4bf0db7f62c38c9965e22a0f42efbd.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">DefaultChannelPipeline还提供了callBeforeAdd、callAfterRemove等方法，在添加删除Handler前后调用。这些方法要求具体ChannelHandler实现了LifeCycleAwareChannelHandler接口。实现了该接口的Handler能够在自己被添加或移除的时候被通知到，亦即调用相应的方法。 <br/>
DefaultChannelPipeline几乎所有的方法都是Synchronized，它是一个线程安全的类。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">6. ChannelEvent</h2>
<p style="margin: 0 0 1.1em;">在Pipeline中流转的事件分为两类，Upstream表示对Channel通知底层IO状态，Downstream表示Channel向底层提交IO请求。在Netty中ChannelEvent的产品体系如下图所示： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片21.png" name="65730e8d-4c95-4f06-b1ef-54428b1286e4" src="/assets/img/67c9d8a13e3132123f1408f2017ad105.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">以下是Netty运行过程中会触发的事件： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片22.png" name="6d49413d-6fdb-4fdd-9893-a0d066ee6087" src="/assets/img/ebb7164b6b5e43ccbd2088262d806615.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">Upstream事件名称均表示状态，比如closed、received之类，Downstream事件名都是动词，表示IO请求。其中两类典型的事件：</p>
<p style="margin: 0 0 1.1em;"><strong style="font-weight: bold;">表示读写事件的MessageEvent</strong> <br/>
messageReceived：当Netty内部IO线程在某个Channel上读取到了数据，便将其包装成ChannelBuffer对象并发起一个UpstreamMessageEvent事件进入Pipeline向上流转，这是一个典型的读取数据过程。</p>
<p style="margin: 0 0 1.1em;">write：写请求的提交是个逆向的过程，Channel#write(Object)最终将要写入的数据包裹成一个DownstreamMessageEvent事件，提交到Pipeline中，最终进入Sink。</p>
<p style="margin: 0 0 1.1em;">Downstream事件中没有read的事件，因为在Netty中，读Channel的请求不是由用户主动发起的，而是由内部IO线程不停地读，一旦有数据再告知用户程序。</p>
<p style="margin: 0 0 1.1em;"><strong style="font-weight: bold;">表示Channel状态改变的ChannelStateEvent</strong> <br/>
用户调用Channel#bound/connect等方法时，实际上是触发相应的Downstream事件，Sink接到事件处理完毕后再触发Upstream的事件通知上层IO操作的完成情况。</p>
<p style="margin: 0 0 1.1em;">Downstream是没有Open事件的，因为一个Channel在生产出来的时候默认就是打开状态，相应的具体实现应该在其构造器中实现打开Channel这个行为，通常还会触发ChannelOpen的Upstream事件。</p>
<p style="margin: 0 0 1.1em;">Netty都是通过Channels这个工具类中的fireXXXEvent静态方法触发事件的，Channels将所有事件类型的触发汇总到一起，整个工程里无论何时何地都可以调用这些方法在指定的 Channel上触发事件流转。</p>
<p style="margin: 0 0 1.1em;">ChannelEvent接口只有两个方法： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片23.png" name="606857fe-5bbc-4be6-b3a1-f2931916038e" src="/assets/img/60846c1d89d8d3d82a71c18cbc1d1991.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>getChannel()返回该Event关联的Channel；</li>
<li>getFuture()返回该Event关联的ChannelFuture对象。每个ChannelEvent在触发的时候都会为其绑定一个ChannelFuture，表示这个事件的执行状态。如果事件是Upstream的，那么返回的总会是SucceededChannelFuture实例表示执行成功，因为Upstream事件触发的时候已经是完成某种IO操作或已经到达某种状态了。反之，如果是Downstream的（即IO请求），则返回的ChannelFuture会被Netty内部随着实际的IO进度而不时的更新状态，即在IO请求执行成功或失败的时候得到“通知“。</li>
</ul>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">7. ChannelSink</h2>
<p style="margin: 0 0 1.1em;">ChannelSink被挂在ChannelPipeline的末端，处理所有从Handler链流入的Downstream事件，即对IO请求（如bind、connect、write）做汇总处理的地方（但不一定在这里做最终的IO操作），也会在处理完后触发Upstream事件。一般在实现中ChannelSink在ChannelFactory内被创建，且只有一个实例，这意味着该ChannelFactory创建的N个Channel可能使用N个不同的Pipeline实例，但所有的Pipeline使用一个共同的Sink。</p>
<p style="margin: 0 0 1.1em;">ChannelSink由底层使用的transport provider提供，它的类图和继承体系如下：</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片24.png" name="22628cdd-1bc7-4689-aefc-d29315f6ea1a" src="/assets/img/2b7453d8aa59e72db0430c57641a0f2c.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>eventSunk(pipeline, event)：处理Downstream事件；</li>
<li>exceptionCaught(pipeline, event, channelPipelineException)：当Pipeline中抛出异常时会调用该方法进行处理</li>
</ol>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片25.png" name="2c72dfaf-527d-4860-af5b-14a93fc79b50" src="/assets/img/548e0a042f986021f3a40227f2b31eaa.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">ChannelSink被分为4个产品族，根据使用场景分为：</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">TCP Client端</h3>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">TCP Server端</h3>
<p style="margin: 0 0 1.1em;">注意： Server端存在两种Channel：Listening和Accepted。二者使用的Sink并不是分开的，而是共用一个Server-side ChannelSink，Sink里同时存在处理Listening Channel和Accepted Channel的逻辑。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">UDP协议</h3>
<p style="margin: 0 0 1.1em;">其实仔细对照下ChannelFactory体系可以发现，这二者的结构几乎是一一对应的，除了Sink少了几个抽象类。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">8. ChannelBuffer</h2>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./图片26.png" name="88f4c85c-450f-43d8-99b1-e54408dd950c" src="/assets/img/168110790797013f3b0e83a91a34babc.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">ChannelBuffer是Netty自己实现的一套类似Java NIO ByteBuffer系统，它是byte[]数组或ByteBuffer的封装，主要的实现类有3个：</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">ByteBufferBackedChannelBuffer</h3>
<p style="margin: 0 0 1.1em;">直接封装了NIO的ByteBuffer系统，具体是Direct Buffer还是Non-direct Buffer要看实例化时传入的ByteBuffer类型；</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">HeapChannelBuffer</h3>
<p style="margin: 0 0 1.1em;">内部就是个byte数组，这里的Heap就是JVM堆的意思。这个实现其实跟NIO的Non-direct ByteBuffer类似，内部都是JVM堆上的一个byte[]。根据网络字节续的不同，HeapChannelBuffer又分为BigEndianHeapChannelBuffer和 LittleEndianHeapChannelBuffer，默认使用的是BigEndianHeapChannelBuffer。Netty在读网络数据时默认使用的是HeapChannelBuffer，HeapChannelBuffer是个大小固定的buffer，Netty每次读网络数据时都会根据前面读取时使用的Buffer大小来预测要分配的空间。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">DynamicChannelBuffer</h3>
<p style="margin: 0 0 1.1em;">可自适应大小的Buffer，它和HeapChannelBuffer的关系很像ArrayList和数组的关系。它内部具体使用什么样的机制实现是由其内部的ChannelBufferFactory决定的，默认是HeapChannelBufferFactory。当容量不够用时会使用该Factory创建一个更大的buffer扩容，并对原数据进行复制。对于在DecodeHandler中的写数据操作，在数据大小未知的情况下通常使用DynamicChannelBuffer。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">复合Buffer：CompositeChannelBuffer</h3>
<p style="margin: 0 0 1.1em;">它的内部是个ChannelBuffer数组，CompositeChannelBuffer在若干个Buffer之上为上层提供一个统一的接口，上层可以“无缝“地，就像操作一个连续的ChannelBuffer一样使用多个异构Buffer。它的目的主要是减少内存拷贝，提高性能。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">WrappedChannelBuffer</h3>
<p style="margin: 0 0 1.1em;">该接口的实现类均是ChannelBuffer的包装器，它们的用途是为底层offer提供“另一种视图“。比如用ReadOnlyChannelBuffer把一个Buffer包装一下，原本可读可写的现在就成了只读的了，但是底层使用的Buffer还是原来那个。实际上是为了重用底层buffer，减少数据的拷贝和内存开销。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">9. ChannelBufferFactory</h2>
<p style="margin: 0 0 1.1em;">ChannelBuffer对应也有一套简单的工厂体系： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片27.png" name="a10f97cd-22d0-4394-bf7e-8b15333b0d44" src="/assets/img/975316f0ae8f81416b3c1d171195ca07.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">具体的实现类有DirectChannelBufferFactory和HeapChannelBufferFactory，前者用于创建ByteBufferBackedChannelBuffer，底层使用NIO的DirectBuffer；后者创建HeapChannelBuffer。这里就涉及到一个问题，Direct Buffer和Non-direct Buffer有什么区别？什么情况下应该用哪种呢？</p>
<p style="margin: 0 0 1.1em;">底层操作系统在只能对进程虚拟空间的一片连续区域内进行IO操作，而在JVM内部，一个byte[]反应到JVM进程的虚拟空间中很可能不是连续的，并且GC可以随意地将其移动。因为数组在JVM中是一个对象，而对象是怎样存储的依赖于具体的JVM实现。DirectBuffer是分配在JVM进程虚拟空间（实际上是native堆）的非堆（JVM Heap）区域的一块连续存储空间，OS内核可以直接使用它作为底层IO操作的输入输出而不需要额外的内存拷贝动作。此外，DirectBuffer不受GC影响，不会在高负载情况下受到频繁的GC对应用线程造成的中断影响。但是它相对堆上的对象而言，创建和销毁的代价都远远高于后者。</p>
<p style="margin: 0 0 1.1em;">如果使用Non-direct buffer，则每次IO的过程，都会使用一个被缓存的小的DirectBuffer对象，先将数据拷贝到后者中，然后再进行实际的IO — 发生了数据拷贝，这正是在网络编程中所要极力避免的。因此，在频繁IO且对性能有要求的场景，我们可以使用DirectBuffer，并在代码中缓存它以避免创建和销毁的开销。这也是对创建和销毁都非常耗资源的“重型对象”的常见处理方式，如线程池、数据库连接池等等。</p>
<p style="margin: 0 0 1.1em;">回到Netty，DirectChannelBufferFactory作为DirectBuffer的生产工厂，会在第一次请求Buffer的时候一次性分配一块较大的ByteBufferBackedChannelBuffer（默认1M），以后每次请求都在它上面slice一块出来返回，当这块“蛋糕”被分完了，则再生产一块“大蛋糕”供使用，这样有效降低了生产DirectBuffer的次数。相比之下，HeapChannelBufferFactory的实现就没这么多花招了，只是简单地调用ChannelBuffers.buffer或ChannelBuffers.wrappedBuffer工具方法，最终创建一个HeapChannelBuffer返回。</p>
<p style="margin: 0 0 1.1em;">对于开发者创建 ChannelBuffer，可使用实用类ChannelBuffers中的工厂方法。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">10. Reactor模式</h2>
<p style="margin: 0 0 1.1em;">终于介绍完了Netty的上层API及它们的产品体系，现在是时候深入到它的内部探索它的代码实现了。虽然Netty的实现有3种transport service，但我们最常用的是NIO实现方式进行TCP协议之上的编程，因此对代码的分析会主要集中在NIO Server端这一块。</p>
<p style="margin: 0 0 1.1em;">Netty使用了经典的Reactor模式，在开始分析代码之前先来复习下理论知识。</p>
<p style="margin: 0 0 1.1em;">使用Old IO库，阻塞IO方式进行网络服务器开发，最简单的模型就是 1 thread per socket，即一个主线程负责Accept连接，一直处于阻塞状态；每收到一个连接即为其分配一个线程进行处理，如下图所示： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片28.png" name="b3907de7-75e1-4b84-9d0c-43d9e51ffec4" src="/assets/img/1850d753be067ed136673e7e538676e9.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">这种模式的缺点在于：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>每个连接一个线程，当并发用户较多时线程数量急剧增长，大大增加系统对线程的管理开销，这将成为主要瓶颈；</li>
<li>网络是不稳定的，此外，如果是长连接，客户端很多时候是沉默的，连接上并不是一直都有数据流动，大部分时候是空闲的。但如果使用阻塞IO和上述线程模型，即使某个连接没有数据可读，该连接占用的线程也会因此而阻塞。有可能在同一时刻存在大量IO阻塞的线程，浪费资源。</li>
</ol>
<p style="margin: 0 0 1.1em;">假如在读写网络的时候，socket不满足条件就返回，不用阻塞着傻傻地等待结果，那么该连接占用的线程就可以去为其他连接服务了。但过段时间socket满足IO条件了（比如有数据过来或者可以写），我们怎么得到通知呢。假想下如果有一个线程专门负责轮询所有的连接监控他们的状态，一旦发现有可读数据或可写空间，就立刻交给某个线程去进行实际的IO操作和业务处理，后者读写直到没有可读数据或无法继续写入，如果还没有完成IO操作，则继续将该连接交还给监控线程，等待下一次状态满足被处理。</p>
<p style="margin: 0 0 1.1em;">这正是NIO带给我们的最大价值：IO多路复用和事件模型、非阻塞IO。NIO的Selector可以监控N个连接的状态，相当于我们设想中的监控线程。我们把连接注册到Selector上时会声明感兴趣的状态，Selector在一次select的过程中发现某些连接正处在它被声明的状态，则把他们挑选出来并将IO事件分发给用户处理。用户程序使用非阻塞IO对其进行“最大努力的”读写，若本次处理没有完成，则继续交由Selector监控等待下次处理。这种由“主动阻塞等待”改为“被动通知非阻塞处理”的方式有效规避了前一种模型中IO阻塞导致大量线程浪费的问题，工作线程每次处理连接都能快速返回，我们可以最大化的利用线程资源，用少的多的线程应对相同规模的连接数。</p>
<p style="margin: 0 0 1.1em;">Reactor模式中，原来的read-decode-compute…处理序列被打碎成N个独立的Handler， Reactor负责多路分离套接字（监控连接状态）并将IO事件分发给相应的Handler，后者进行非阻塞的IO读写，或进行编码解码业务处理。这种模型虽然占用资源少，但也有缺点：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>事件分发的过程可能很慢，要根据连接和事件找到正确的Handler。</li>
<li>增加了代码编写的难度，处理逻辑被强制要求拆分成一个个的Handler，并且由于Handler可能不能一次性做完全部IO工作，必须保存处理状态等待下次被通知。</li>
</ol>
<p style="margin: 0 0 1.1em;">最简单的Reactor模型如下所示： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片29.png" name="49bb83b7-4e01-489c-8593-727caa7415e7" src="/assets/img/53df206cf3d124e3bbf6f00573824c94.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">单线程单Reactor，只有一个Selector同时负责监控Server Socket和Accepted Socket，并将IO事件派发给Acceptor和处理IO的Handler，Acceptor接受连接请求创建Accepted Socket并注册到Reactor。Reactor分发事件和执行Handler的过程是串行的，无法充分利用多核资源，这种模型实际用的不多。</p>
<p style="margin: 0 0 1.1em;">第二种Reactor模型在Handler的处理中加入了线程池，编码、业务计算、解码等非IO操作的过程被创建成一个个任务提交到线程池中： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片30.png" name="857f7c78-c497-43ef-a7fa-e9cab99363e1" src="/assets/img/058b8dceb9781aa6d55590537cdbfcb1.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">第三种模型将Reactor分成两个部分，MainReactor通常只有一个，Listening Socket注册在它上面，专门监听连接请求，并将创建的Accepted Socket注册到SubReactor上，SubReactor可以有多个，负责处理已连接的socket，其中业务处理的部分仍然交给线程池进行，如下图所示： <br/>
<img alt="Alt text" class="en-media" longdesc="./图片31.png" name="1d0ffadf-1469-4ce3-b7e4-a7b76528dba4" src="/assets/img/9015475f80a88228f7afb5b525d14d1d.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">Netty的NIO实现采用的模型是第三种的变种，业务部分Handler链并没有使用连接池，而是类似第一种模型中采用串行处理。注意，SubReactor“分派事件 – Handler处理 – 分派下一次事件”这个处理过程也是串行的，只有几个Reactor是并行的，所以在 Netty3 中，<strong style="font-weight: bold;">一定不要在 handler 中做耗时或者阻塞的动作，否则 IO 线程会被 block，后续连接得不到响应。会引起阻塞的动作应放在单独的线程中异步去做</strong>。</p></div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">11. Netty的NIO Server端实现</h2>
<p style="margin: 0 0 1.1em;">首先我们来看看Server端Listening Channel的创建和MainReactor的启动，通常我们使用ServerBootstrap启动服务器：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #75715e;">// Configure the server.</span>
        ServerBootstrap bootstrap = <span style="color: #f92672;">new</span> ServerBootstrap(
                <span style="color: #f92672;">new</span> NioServerSocketChannelFactory(
                        Executors.newCachedThreadPool(),
                        Executors.newCachedThreadPool()));

        <span style="color: #75715e;">// Set up the pipeline factory.</span>
        bootstrap.setPipelineFactory(<span style="color: #f92672;">new</span> ChannelPipelineFactory() {
            <span style="color: #f92672;"><span style="color: #66d9ef;">public</span> ChannelPipeline <span style="color: #a6e22e;">getPipeline</span><span style="color: #f8f8f2;">()</span> <span style="color: #66d9ef;">throws</span> Exception </span>{
                <span style="color: #f92672;">return</span> Channels.pipeline(<span style="color: #f92672;">new</span> EchoServerHandler());
            }
        });

        <span style="color: #75715e;">// Bind and start to accept incoming connections.</span>
        bootstrap.bind(<span style="color: #f92672;">new</span> InetSocketAddress(<span style="color: #ae81ff;">8080</span>));</code></pre>
<p style="margin: 0 0 1.1em;">第一句为ServerBootstrap指定了ChannelFactory，后续会用这个ChannelFactory在Server端创建一个类型为NioServerSocketChannel的Listening Channel。</p>
<p style="margin: 0 0 1.1em;">第二步指定了PipelineFactory，所有Accepted Channel在创建时会使用该工厂创建一个Pipeline实例用于响应事件。生产Pipeline时先使用Channels.pipeline静态工具方法创建一个DefaultChannelPipeline实例，并往里添加一个我们自己实现的EchoServerHandler。</p>
<p style="margin: 0 0 1.1em;">最后一句将bootstrap绑定到一个端口，整个过程就完成了，就这么简单~！</p>
<p style="margin: 0 0 1.1em;">当然，大量的细节被隐藏在内部了。先看Channel工厂：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #f92672;">private</span> <span style="color: #f92672;">final</span> WorkerPool&lt;NioWorker&gt; workerPool;
<span style="color: #f92672;">private</span> <span style="color: #f92672;">final</span> BossPool&lt;NioServerBoss&gt; bossPool;
<span style="color: #f92672;">private</span> <span style="color: #f92672;">final</span> NioServerSocketPipelineSink sink;</code></pre>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><p style="margin: 0 0 1.1em;">NioServerSocketChannelFactory维护所有的Boss/Worker，即IO线程。</p>
<p style="margin: 0 0 1.1em;">构造器的两个参数指定Boss/Worker使用的线程池：</p>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>BossExecutor：执行MainReactor的线程池，虽然大部分情况下只有一个Main Reactor，即线程池中只有一个线程（通常称之为Boss Thread），但仍然通过一个线程池进行管理，这是因为如果同一VM中存在多个Netty服务器端程序，可以把它们的Main Reactor使用的线程都集中起来到一个线程池中进行管理；</li>
<li>WorkerExecutor：执行SubReactor的线程池，Netty中的SubReactor是NioWorker类。</li>
<li>workerCount：SubReactor的个数。默认是<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">CPU核数 * 2</code>。</li></ul></li>
<li><p style="margin: 0 0 1.1em;">其次，NioServerSocketChannelFactory维护一个NioServerSocketPipelineSink，这个Sink将会处理Listening Socket和所有Accepted Socket的Downstream事件。</p></li>
</ol>
<p style="margin: 0 0 1.1em;">在bootstrap.bind内部，先手动构造一个Pipeline，它是为ServerSocketChannel服务的，因此也称为boss pipeline。这个管道中只有一个Handler—Binder，Binder是一个内部类，负责Server Channel绑定到某个端口的操作。</p>
<p style="margin: 0 0 1.1em;">接下来通过factory创建NioServerSocketChannel ，并装配boss pipeline（以及factory内部的sink）：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">　　    ChannelHandler binder = <span style="color: #f92672;">new</span> Binder(localAddress, futureQueue);
        ChannelHandler parentHandler = getParentHandler();

        ChannelPipeline bossPipeline = pipeline();
        bossPipeline.addLast(<span style="color: #e6db74;">"binder"</span>, binder);
        <span style="color: #f92672;">if</span> (parentHandler != <span style="color: #f92672;">null</span>) {
            bossPipeline.addLast(<span style="color: #e6db74;">"userHandler"</span>, parentHandler);
        }

        Channel channel = getFactory().newChannel(bossPipeline);</code></pre>
<p style="margin: 0 0 1.1em;">在newChannel方法中，除了打开一个ServerSocketChannel，还在该channel上触发一个ChannelOpen事件（ 这印证了之前提到的，NioServerSocketChannel是基于ServerSocketChannel实现的，并且一个Channel被创建出来时就是Open的），Channels.fireChannelOpen方法创建一个UpstreamChannelStateEvent事件，进入boss pipeline流转：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">　　<span style="color: #f92672;"><span style="color: #66d9ef;">public</span> <span style="color: #66d9ef;">static</span> <span style="color: #66d9ef;">void</span> <span style="color: #a6e22e;">fireChannelOpen</span><span style="color: #f8f8f2;">(Channel channel)</span> </span>{
        <span style="color: #75715e;">// Notify the parent handler.</span>
        <span style="color: #f92672;">if</span> (channel.getParent() != <span style="color: #f92672;">null</span>) {
            fireChildChannelStateChanged(channel.getParent(), channel);
        }

        channel.getPipeline().sendUpstream(
                <span style="color: #f92672;">new</span> UpstreamChannelStateEvent(
                        channel, ChannelState.OPEN, Boolean.TRUE));
　　}</code></pre>
<p style="margin: 0 0 1.1em;">Boss pipeline 的 Binder负责调用Channel的bind方法进行绑定：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">evt.getChannel().bind(localAddress)</code></pre>
<p style="margin: 0 0 1.1em;">正如前面提到的，Channel的IO方法基本上都是通过Channels的工具方法触发一个Downstream的事件，是一种“提交请求”的性质，Channels.bind方法也是如此：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #f92672;"><span style="color: #66d9ef;">public</span> <span style="color: #66d9ef;">static</span> ChannelFuture <span style="color: #a6e22e;">bind</span><span style="color: #f8f8f2;">(Channel channel, SocketAddress localAddress)</span> </span>{
        <span style="color: #f92672;">if</span> (localAddress == <span style="color: #f92672;">null</span>) {
            <span style="color: #f92672;">throw</span> <span style="color: #f92672;">new</span> NullPointerException(<span style="color: #e6db74;">"localAddress"</span>);
        }
        ChannelFuture future = future(channel);
        channel.getPipeline().sendDownstream(<span style="color: #f92672;">new</span> DownstreamChannelStateEvent(
                channel, future, ChannelState.BOUND, localAddress));
        <span style="color: #f92672;">return</span> future;
　　}</code></pre>
<p style="margin: 0 0 1.1em;">该方法创建了一个DownStream的bind事件传入boss pipeline，并为其创建了一个ChannelFuture对象当做bind请求执行状态的容器。</p>
<p style="margin: 0 0 1.1em;">Boss pipeline中并没有Handler处理Downstream事件（Binder是个UpstreamHandler），于是事件通过Pipeline“沉入”Sink，还记得在NioServerSocketChannelFactory的那个Sink么，对，就是它。在它的eventSunk方法中根据Channel的类型走两条不同的逻辑，分别对应Server端的两种Channel – Listening Channel和Accepted Channel：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">　　<span style="color: #f92672;"><span style="color: #66d9ef;">public</span> <span style="color: #66d9ef;">void</span> <span style="color: #a6e22e;">eventSunk</span><span style="color: #f8f8f2;">(ChannelPipeline pipeline, ChannelEvent e)</span> <span style="color: #66d9ef;">throws</span> Exception </span>{
        Channel channel = e.getChannel();
        <span style="color: #f92672;">if</span> (channel <span style="color: #f92672;">instanceof</span> NioServerSocketChannel) {
            handleServerSocket(e);
        } <span style="color: #f92672;"><span style="color: #66d9ef;">else</span> <span style="color: #a6e22e;">if</span> <span style="color: #f8f8f2;">(channel <span style="color: #66d9ef;">instanceof</span> NioSocketChannel)</span> </span>{
            handleAcceptedSocket(e);
        }
　　}</code></pre>
<p style="margin: 0 0 1.1em;">handleServerSocket方法中只会处理上层提交过来的close、bind、unbind请求：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">　　<span style="color: #f92672;">switch</span> (state) {
        <span style="color: #f92672;">case</span> OPEN:
            <span style="color: #f92672;">if</span> (Boolean.FALSE.equals(value)) {
                close(channel, future);
            }
            <span style="color: #f92672;">break</span>;
        <span style="color: #f92672;">case</span> BOUND:
            <span style="color: #f92672;">if</span> (value != <span style="color: #f92672;">null</span>) {
                bind(channel, future, (SocketAddress) value);
            } <span style="color: #f92672;">else</span> {
                close(channel, future);
            }
            <span style="color: #f92672;">break</span>;
        }</code></pre>
<p style="margin: 0 0 1.1em;">噢bind方法，终于到了一个干实事儿的地方了，在bind里将N久之前就实例化好了的ServerSocketChannel绑定到指定端口上，更新ChannelEvent的ChannelFuture对象，并最终启动MainReactor不停Accept连接，流程如下：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #75715e;">//NIO实际ServerSocketChannel.bind操作</span>
channel.socket.socket().bind(localAddress, channel.getConfig().getBacklog());
bound = <span style="color: #f92672;">true</span>;
future.setSuccess();    <span style="color: #75715e;">//更新future</span>
fireChannelBound(channel, channel.getLocalAddress()); <span style="color: #75715e;">//触发一个Upstream的事件，通知Pipeline已经绑定成功</span>
<span style="color: #75715e;">//启动MainReactor</span>
Executor bossExecutor = ((NioServerSocketChannelFactory) channel.getFactory()).bossExecutor;
DeadLockProofWorker.start(bossExecutor,<span style="color: #f92672;">new</span> ThreadRenamingRunnable(<span style="color: #f92672;">new</span> Boss(channel),<span style="color: #e6db74;">"New I/O server boss #"</span> + id + <span style="color: #e6db74;">" ("</span> + channel + <span style="color: #e6db74;">')'</span>));</code></pre>
<p style="margin: 0 0 1.1em;">Netty的MainReactor是Boss类，这是NioServerSocketPipelineSink的一个内部类，它实现了Runnable接口。启动MainReactor，其实就是用ServerSocketChannel实例化一个Boss任务（一般来说一个Netty服务器端程序也只会有这一个Boss任务，这意味着BossExecutor中大部分情况下只有一个Boss Thread）并提交到NioServerSocketChannelFactory中的BossExecutor线程池中执行。</p>
<p style="margin: 0 0 1.1em;">Boss类在实例化时立刻创建一个Selector并将ServerSocketChannel注册上去，监听其OP_ACCEPT事件。它的run方法是一个死循环，只做一件事，那就是不停地获取连接，创建Accepted Channel并将其注册到subReactor，即NioWorker上。</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #f92672;">try</span> {
    <span style="color: #f92672;">for</span> (;;) {
        <span style="color: #f92672;">try</span> {
            <span style="color: #f92672;">if</span> (selector.select(<span style="color: #ae81ff;">1000</span>) &gt; <span style="color: #ae81ff;">0</span>) {
                selector.selectedKeys().clear();
            }

            SocketChannel acceptedSocket = channel.socket.accept();
            <span style="color: #f92672;">if</span> (acceptedSocket != <span style="color: #f92672;">null</span>) {
                registerAcceptedChannel(acceptedSocket, currentThread);
            }
        } <span style="color: #f92672;">catch</span> (Throwable e) {
            logger.warn(
                    <span style="color: #e6db74;">"Failed to accept a connection."</span>, e);
            <span style="color: #f92672;">try</span> {
                Thread.sleep(<span style="color: #ae81ff;">1000</span>);
            } <span style="color: #f92672;">catch</span> (InterruptedException e1) {
                <span style="color: #75715e;">// Ignore</span>
            }
        }
    }
} <span style="color: #f92672;">finally</span> {
    channel.shutdownLock.unlock();
    closeSelector();
}</code></pre>
<p style="margin: 0 0 1.1em;">创建并注册Accepted Channel的过程是Boss#registerAcceptedChannel方法负责的：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">ChannelPipeline pipeline =  channel.getConfig().getPipelineFactory().getPipeline();
NioWorker worker = nextWorker();
worker.register(<span style="color: #f92672;">new</span> NioAcceptedSocketChannel(
　　channel.getFactory(),
　pipeline,
　channel,
　NioServerSocketPipelineSink.<span style="color: #f92672;">this</span>,
　acceptedSocket,
　worker, currentThread), <span style="color: #f92672;">null</span>);</code></pre>
<p style="margin: 0 0 1.1em;">创建NioAcceptedSocketChannel使用的Pipeline是通过ServerBootstrap指定的PipelineFactory生产的，里面被填充了我们提供了自定义Handler。通过nextWorker方法决定该Channel要被提交到哪儿去，这个方法简单地轮流使用所有NioWorker。注意，NioAcceptedSocketChannel并没有用个工厂来创建，而是直接new的，这也印证了之前提到的，Server端的Accepted Channel是由ServerChannel间接地通过new生成。</p>
<p style="margin: 0 0 1.1em;">小结：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>ChannelFactory除了负责Channel生产，还负责维护Boss和Worker –  职责太多，4中将这二者分开了；</li>
<li>Sink负责汇总处理DownStream事件： <br/>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>对于write，判断是否当前是否IO线程，是则立即执行，否则进入NioWorker的队列排队。这是为了保证最终的write动作只由IO线程做；</li>
<li>对于bind/close等，则直接操作socket进行IO动作。</li></ul></li>
<li>在 NioServerSocketChannle 的 boss pipeline 中触发的两次事件完成了bootstrap： <br/>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>open的UpStream事件，表明Server Channel已被创建；</li>
<li>boss pipeline 中的 Binder 接收倒 open事件后，触发一个DownStream的 bind 事件；</li>
<li>Sink进行实际的bind动作，启动Boss，Boss进入event loop。至此，整个流程完毕。</li></ul></li>
</ol>
<blockquote style="padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;">
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;"><em>a. Sink为什么存在？</em> <br/>
  Downstream事件本质是对底层transport service的请求，必须要有个地方受理这些请求，Sink的作用就在此。对不同的Downstream事件，Sink可能直接处理，也可能提交给Worker线程。</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;"><em>b. Sink为什么会提交write请求到Worker而不立即执行？其他的如bind/close请求为何直接执行？</em> <br/>
  这涉及到netty的线程模型。<strong style="font-weight: bold;">事件发起后在pipeline中的流转是立即串行执行的</strong>，且任意线程都有可能随时在channel上发起事件，因此handler/sink可能运行在User Thread中，也可能在IO thread中。Write动作必须由IO thread执行以防止线程中断导致socket关闭的问题；其他动作在User Thread中做也没关系。</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;">这样的设定给handler和sink带来了并发问题，netty4中改成了<strong style="font-weight: bold;">所有outbound event（而不仅是实际的write IO动作）</strong>都必须由IO thread执行，所有在user threaed中fire的事件连同其pipeline，全部得先进入IO thread的队列，稍后进行实际的事件流转。这就保证了handler/sink始终运行在某一个IO thread中，不用再担心并发的问题；Sink也可以省略了。</p>
</blockquote>
<p style="margin: 0 0 1.1em;">说完了MainReactor，我们接着来看看SubReactor。SubReactor负责所有AcceptedChannel的通信，它是延迟启动的，MainReactor调用NioWorker#register方法注册一个Channel时，先检查自己有没有启动，如果没有，则开启自己的selector，并把自己提交到workerExecutor线程池中执行（还记得NioServerSocketChannelFactory中的workerExecutor么？），最后生成一个RegisterTask即该Accepted Channel的注册任务，添加到NioWorker内部的registerTaskQueue（代码较长这里就不贴了）。</p>
<p style="margin: 0 0 1.1em;">为什么不立刻使用channel.register(selector, ops, attachment)方法直接注册到Selector呢？网上查资料发现是处于效率问题的考虑，这种方式至少要加两次锁，其中Selector内部的key集合竞争非常激烈。但是在Netty中注册的动作只由MainReactor单线程进行，应该没有并发的场景才对。Anyway，Netty采取的方式就是使用一个缓冲任务队列，每次注册先进队列，由workerThread执行循环时会首先处理该队列，执行真正的注册动作。</p>
<p style="margin: 0 0 1.1em;">NioWorker和Boss一样，都实现了Runnable接口被线程池执行，如果我们使用一个没有上限的线程池如Executors.newCachedThreadPool(),则每个NioWorker都会对应一个worker Thread。NioWorker#run()像Boss#run()一样，也是死循环。每次循环中首先在Selector select一下，然后依次执行内部的注册任务队列（registerTaskQueue）、写任务队列（writeTaskQueue，关于这个队列后续还会说明）、处理selectedKeys。最后，如果Selector上没有注册的连接了，就把自己关闭，从workerExecutor的任务队列中出队，释放自己占用的线程资源。这一部分的关键代码如下（有删减）：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #f92672;">for</span> (;;) {
    wakenUp.set(<span style="color: #f92672;">false</span>);
    SelectorUtil.select(selector);
    <span style="color: #f92672;">if</span> (wakenUp.get()) {
        selector.wakeup();
    }

    cancelledKeys = <span style="color: #ae81ff;">0</span>;
    processRegisterTaskQueue();
    processWriteTaskQueue();
    processSelectedKeys(selector.selectedKeys());

    <span style="color: #75715e;">// Exit the loop when there's nothing to handle.</span>
    <span style="color: #75715e;">// The shutdown flag is used to delay the shutdown of this</span>
    <span style="color: #75715e;">// loop to avoid excessive Selector creation when</span>
    <span style="color: #75715e;">// connections are registered in a one-by-one manner instead of</span>
    <span style="color: #75715e;">// concurrent manner.</span>
    <span style="color: #f92672;">if</span> (selector.keys().isEmpty()) {
        <span style="color: #f92672;">if</span> (shutdown || executor <span style="color: #f92672;">instanceof</span> ExecutorService &amp;&amp; ((ExecutorService) executor).isShutdown()) {

            <span style="color: #f92672;">synchronized</span> (startStopLock) {
                <span style="color: #f92672;">if</span> (registerTaskQueue.isEmpty() &amp;&amp; selector.keys().isEmpty()) {
                    started = <span style="color: #f92672;">false</span>;
                    <span style="color: #f92672;">try</span> {
                        selector.close();
                    } <span style="color: #f92672;">catch</span> (IOException e) {
                        logger.warn(<span style="color: #e6db74;">"Failed to close a selector."</span>, e);
                    } <span style="color: #f92672;">finally</span> {
                        <span style="color: #f92672;">this</span>.selector = <span style="color: #f92672;">null</span>;
                    }
                    <span style="color: #f92672;">break</span>;
                } <span style="color: #f92672;">else</span> {
                    shutdown = <span style="color: #f92672;">false</span>;
                }
            }
        } <span style="color: #f92672;">else</span> {
            <span style="color: #75715e;">// Give one more second.</span>
            shutdown = <span style="color: #f92672;">true</span>;
        }
    } <span style="color: #f92672;">else</span> {
        shutdown = <span style="color: #f92672;">false</span>;
    }
}</code></pre>
<p style="margin: 0 0 1.1em;">我们先来看对select出来的keys是怎么处理的，这个逻辑在processSelectedKeys方法中，该方法循环selectedKeys，看他们是哪种类型，如果是read就绪，则调用read(SelectionKey)方法进行IO读，如果是write就绪，则走writeFromSelectorLoop(SelectionKey)进而调用内部的write0(NioSocketChannel)方法。</p>
<p style="margin: 0 0 1.1em;">服务器端的逻辑基本上都是从读开始的，读的过程是由Netty内部发起的，先来看看read方法。它的基本流程是：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>使用该Channel配置的读缓存预测器预测此次需要分配空间大小，向内部的recvBufferPool申请一块ByteBuffer；</li>
<li>由SocketChannel的内核缓冲区向Buffer中读数据，直到数据读取完毕或Buffer满；</li>
<li>使用该Channel配置的ChannelBufferFactory创建一块同样大小的ChannelBuffer，将Buffer内容拷贝过去—这里出现了一次内存拷贝操作；</li>
<li>向recvBufferPool归还申请的ByteBuffer，向读缓存预测器反馈此次读取数据大小；</li>
<li>触发一个Upstream的MessageReceived事件，将ChannelBuffer传递出去，逻辑由此进入Pipeline。</li>
</ol>
<p style="margin: 0 0 1.1em;">这里用到了一个有意思的数据结构SocketReceiveBufferPool，这是一个小的DirectBuffer缓存池，避免频繁的创建和销毁DirectBuffer，用于SocketChannel的IO读操作，每个NioWorker都有一个。它的内部是一个用软引用对象包裹起来的ByteBuffer数组，内存不够时池内的buffer可以被GC。</p>
<p style="margin: 0 0 1.1em;">其基本原理为：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><strong style="font-weight: bold;">请求指定大小N的buffer</strong>： <br/>
遍历内部数组，找到第一个容量大于等于N的buffer返回。若数组为空或没有满足条件的buffer，则调用ByteBuffer.allocateDirect(int)分配大小为N的buffer返回。</li>
<li><strong style="font-weight: bold;">归还buffer</strong>： <br/>
遍历数组，找到第一个空位，插入。若数组已满，找到第一个比它小的buffer，将其替换。</li>
</ol>
<p style="margin: 0 0 1.1em;">读的过程似乎乏善可陈，那么写呢？当调用Channel#write时会发生什么呢？</p>
<p style="margin: 0 0 1.1em;">看到这里应该大家都心领神会了，肯定又是一个携带ChannelFuture对象以及ChannelBuffer的Downstream的事件。没错，依然是向pipeline发送一个DownstreamMessageEvent，如果在半路上没有其他Handler拦截了，最终会到Sink中被处理。</p>
<p style="margin: 0 0 1.1em;">Sink#handleAcceptedSocket方法中，对IO写请求的处理逻辑如下：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;">    MessageEvent event = (MessageEvent) e;
    NioSocketChannel channel = (NioSocketChannel) event.getChannel();
    <span style="color: #f92672;">boolean</span> offered = channel.writeBuffer.offer(event);
    <span style="color: #f92672;">assert</span> offered;
    channel.worker.writeFromUserCode(channel);
首先把该写事件放入Channel内部的写请求缓冲队列--writeBuffer中，然后调用NioWorker# writeFromUserCode方法，后者的实现也很简单：
　　<span style="color: #f92672;">if</span> (!channel.isConnected()) {
    cleanUpWriteBuffer(channel);
    <span style="color: #f92672;">return</span>;
}

<span style="color: #f92672;">if</span> (scheduleWriteIfNecessary(channel)) {
    <span style="color: #f92672;">return</span>;
}

<span style="color: #75715e;">// From here, we are sure Thread.currentThread() == workerThread.</span>

<span style="color: #f92672;">if</span> (channel.writeSuspended) {
    <span style="color: #f92672;">return</span>;
}

<span style="color: #f92672;">if</span> (channel.inWriteNowLoop) {
    <span style="color: #f92672;">return</span>;
}

write0(channel);</code></pre>
<p style="margin: 0 0 1.1em;">这里出现了一个奇怪的方法scheduleWriteIfNecessary，该方法的会先判断当前线程是不是WorkerThread，如果不是，就把该Channel内部的一个writeTask添加到NioWorker的writeTaskQueue中并返回true，接下来就不会走write0方法而是直接返回了。WriteTask是NioSocketChannel的一个内部类，它的主要作用就是flush Channel的整个写缓冲队列（writeBuffer）。在NioWorker#run()中，下一次循环会首先执行writeTaskQueue队列中的所有任务，这个时候才会发生真正的IO写操作。</p>
<p style="margin: 0 0 1.1em;">这种很奇怪的方式是为了保证，Netty中所有实际的IO写操作都发生在WorkerThread中，这是因为:</p>
<p style="margin: 0 0 1.1em;">nio的socket channel都实现了java.nio.channels.InterruptibleChannel接口。这意味着： <br/>
1、socketChannel可以被异步被关闭，在它上阻塞的线程会被唤醒并抛出AsynchronousCloseException异常； <br/>
2、如果一个在该channel上阻塞的线程被thread#interrupt()方法中断，channel也会被关闭，阻塞线程会被唤醒并抛出ClosedByInterruptException异常。并且，如果在调用 channel的IO方法之前，线程已经设置了中断状态，同样会引起channel关闭和抛出ClosedByInterruptException。</p>
<p style="margin: 0 0 1.1em;">因此，在用户线程中进行IO操作，有可能因为线程终端而引起socket关闭，基于此，netty保证所有的IO操作均在workerThread中完成，代价是写操作不是实时的，可能会有一定时间的延迟。</p>
<p style="margin: 0 0 1.1em;">write0(Channel)方法是真正对Socket进行写操作的地方，同样，用于IO写操作的ByteBuffer也有一个池缓存着—SocketSendBufferPool。write0循环channel内部的写缓存队列，对每个写事件“尽可能地”写入到Socket中，并同时更新该Event对应的Future对象。如果本次没有写完，则继续监听该Channel的OP_WRITE事件，下次唤醒接着继续写入，否则取消OP_WRITE监听。</p>
<p style="margin: 0 0 1.1em;">我们平常所说的“对socket的读写”其实最终是和底层伯克利套接字的内核缓冲区打交道，读是从该内核缓冲区中读，写是往该缓冲区中写，这之下的具体网络传输对上层应用程序而言完全是透明和异步的，假设接收方的接收速率慢于Server端的发送速率，最终会导致Client端Socket的内核缓冲区满，进而导致Server端的内核缓冲区满，Server端无法继续发送数据。在NIO编程中必须要小心处理OP_WRITE事件，因为只要内核缓冲区有空间就会触发该事件，一般的作法是在事件处理中首先将该事件监听取消，如有需要最后再重新监听。</p>
<p style="margin: 0 0 1.1em;">在写数据时也有一个小优化，在高负载情况经常出现明明触发OP_WRITE事件但实际写入0字节的情况，Netty采用了一种类似“自旋锁”的策略，少量循环测试若干次，如果测试成功就开始写数据，否则才放弃，这段代码如下：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #f92672;">long</span> localWrittenBytes = <span style="color: #ae81ff;">0</span>;
<span style="color: #75715e;">/*
 * 将SenBuffer写入channel。
 * 这里用了一个小优化，类似并发编程中的自旋锁，当发现内核写缓存满，即write返回
　　　* 0时会少量循环尝试写入若干次（默认16），直到某次写入成功。
 */</span>
<span style="color: #f92672;">for</span> (<span style="color: #f92672;">int</span> i = writeSpinCount; i &gt; <span style="color: #ae81ff;">0</span>; i--) {
    localWrittenBytes = buf.transferTo(ch);
    <span style="color: #f92672;">if</span> (localWrittenBytes != <span style="color: #ae81ff;">0</span>) {
        writtenBytes += localWrittenBytes;
        <span style="color: #f92672;">break</span>;
    }
    <span style="color: #f92672;">if</span> (buf.finished()) {
        <span style="color: #f92672;">break</span>;
    }
}</code></pre>
<hr style="-moz-box-sizing: content-box; box-sizing: content-box; height: 0; margin-top: 21px; margin-bottom: 21px; border: 0; border-top: 1px solid rgba(102,128,153,0.1); margin: 2em 0;"/>
<p style="margin: 0 0 1.1em;">线程模型 的参考资料：</p>
<p style="margin: 0 0 1.1em;"><a href="https://www.evernote.com/OutboundRedirect.action?dest=https%3A%2F%2Fgithub.com%2Fnetty%2Fnetty%2Fwiki%2FThread-model" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Github上的WIKI：Thread Model</a></p>
<blockquote style="padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;">
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">To put simply, for a channel:</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;">Regardless of its transport and type, its all upstream (i.e. inbound) events must be fired from the thread that performs I/O for the channel (i.e. I/O thread).</p></li>
<li><p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;">All downstream (i.e. outbound) events can be triggered from any thread including the I/O thread and non-I/O threads. However, any upstream events triggered as a side effect of the downstream event must be fired from the I/O thread. (e.g. If Channel.close() triggers channelDisconnected, channelUnbound, and channelClosed, they must be fired by the I/O thread.</p></li>
</ol>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">Current problems (UGLY - causes a race condition in an upstream handler, BAD - does not cause a race condition but violates the expected thread model):</p>
<ol style="margin-top: 0; margin-bottom: 0;"><li>UGLY: The upstream events triggered as a side effect of a downstream event is triggered by the caller thread,</li>
</ol>
</blockquote>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>UGLY: The local transport always uses a caller thread to trigger an event.</li>
<li>BAD: channelOpen is triggered by the thread that called ChannelFactory.newChannel(), which is not an I/O thread. It’s kind of bad but otherwise its not possible to limit the concurrent active channels by closing the channel here. If we would do this in the IO-Thread it would not be that efficient.</li>
<li>BAD: Client-side channels are run by two I/O threads. One that makes a connection attempts and the other that does actual I/O.</li>
</ol>
<p style="margin: 0 0 1.1em;"><a href="http://stackoverflow.com/questions/11014897/netty-architecture-questions-about-nioworker-loop-again" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Netty architecture - questions about NioWorker loop again</a></p>
<blockquote style="padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;">
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">There are two questions in this post.</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">The first question is: is it possible handler queues too long and cannot do process SelectKeys() in time?</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">Yes. However, it doesn’t seem to happen unless your handler implementation abuses intentionally.</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">The second question is: why is write operation always performed in the I/O loop thread?</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 1.1em;">Otherwise 1) you will see a lot of contention between writer threads if you write from different threads, 2) you will see various socket exceptions due to possible race conditions (connection reset, etc), and 3) Netty internal will become more complicated to deal with such conditions.</p>
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;">Please note that the thread model became more strict and event loop implementation became much simpler in Netty 4, so you might want to take a look in there, too.</p>
</blockquote>
<p style="margin: 0 0 1.1em;"><a href="http://stackoverflow.com/questions/8320290/netty-requires-sending-in-the-same-thread-as-select-which-delays-sends/8338005#8338005" style="background: transparent; color: #1980e6; text-decoration: none;" target="_blank">Netty requires sending in the same thread as select() which delays sends</a> <br/>
Is it possible for Netty to create a worker thread that does all the sends for a group of sockets? It appears that currently, netty posts outbound messages to a queue and attempts to wake up the selector which then copies the data into an unused buffer and sends it. This takes time. Is it possible to send directly from a different thread?</p>
<blockquote style="padding: 15px 20px; margin: 0 0 1.1em; border-left: 5px solid rgba(102,128,153,0.075); border-left-width: 10px; background-color: rgba(102,128,153,0.05); border-top-right-radius: 5px; border-bottom-right-radius: 5px;">
<p style="margin: 0 0 1.1em; font-size: 1em; font-weight: 300; line-height: 1.45; margin-bottom: 0;">It is not possible. Netty has no idea about from which thread a user will call write(). Therefore, it needs a write request queue and a dedicated loop to perform writes. Otherwise the application will suffer from contention depending on how a user wrote his/her application. Under load, having a dedicated I/O loop and running a protocol with pipelining seem to yield higher throughput.</p>
</blockquote></div><div></div></div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html&text=Netty3 源码分析" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html&title=Netty3 源码分析" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->
<!-- 
      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">目录</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div> -->
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>
    <button id="js-toc"><span id="icon-list" class="fa fa-list-ul"></span></button>
    <div id="post__toc">
      <span id="post__toc-title">目录</span>
      <ul id="post__toc-ul"></ul>
    </div>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
