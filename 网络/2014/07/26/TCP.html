<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>TCP</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">所有文章 <span class="post_count"></span></li>
          <li id="js-label2" class="tags__li tags-btn">并发<span class="post_count"></span></li>
          <li id="js-label3" class="tags__li tags-btn">jvm<span class="post_count"></span></li>
          <li id="js-label4" class="tags__li tags-btn">算法<span class="post_count"></span></li>
          <li id="js-label5" class="tags__li tags-btn">数据库<span class="post_count"></span></li>
          <li id="js-label6" class="tags__li tags-btn">cache<span class="post_count"></span></li>
          <li id="js-label7" class="tags__li tags-btn">c和os<span class="post_count"></span></li>
          <li id="js-label8" class="tags__li tags-btn">网络<span class="post_count"></span></li>
          <li id="js-label9" class="tags__li tags-btn">工作<span class="post_count"></span></li>
          <li id="js-label10" class="tags__li tags-btn">设计<span class="post_count"></span></li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:novohust@163.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2015/08/17/%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B8%A9%E7%9A%84%E5%87%A0%E4%B8%AA(%E5%B8%B8%E8%AF%86)%E5%9D%91.html"><span class="pl__circle"></span><span class="pl__title">消息中心开发过程中踩的几个(常识)坑</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/08/17/%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">异常</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/08/17/Restful%20API%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83.html"><span class="pl__circle"></span><span class="pl__title">Restful API 的设计规范</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/InnoDB%20%E9%94%81.html"><span class="pl__circle"></span><span class="pl__title">InnoDB 锁</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2015/08/17/INSERT%20ON%20DUPLICATE%20KEY%20UPDATE%20%E5%87%A0%E4%B8%AA%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">INSERT ON DUPLICATE KEY UPDATE 几个要注意的问题</span><span class="pl__date">Aug 2015</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2015/05/05/GIT%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html"><span class="pl__circle"></span><span class="pl__title">GIT常用操作</span><span class="pl__date">May 2015</span></a>
        
          <a class="设计 pl__all" href="/%E8%AE%BE%E8%AE%A1/2015/04/02/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">常用设计模式的总结</span><span class="pl__date">Apr 2015</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/09/11/ThreadLocal%20%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">ThreadLocal 分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/04/MapReduce%20Algorithms.html"><span class="pl__circle"></span><span class="pl__title">MapReduce Algorithms</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/09/03/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E7%AC%94%E8%AE%B0.html"><span class="pl__circle"></span><span class="pl__title">高性能网络通讯笔记</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Skyline监控系统工作原理分析</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="工作 pl__all" href="/%E5%B7%A5%E4%BD%9C/2014/09/03/Skyline%20timeseries%E5%BC%82%E5%B8%B8%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Skyline timeseries异常判定算法</span><span class="pl__date">Sep 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">排序总结</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"><span class="pl__circle"></span><span class="pl__title">快速排序</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/08/05/%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">几个常见的概率问题</span><span class="pl__date">Aug 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/31/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html"><span class="pl__circle"></span><span class="pl__title">常见的HTTP状态码</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/28/BloomFilter.html"><span class="pl__circle"></span><span class="pl__title">BloomFilter</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="jvm pl__all" href="/jvm/2014/07/27/gc.html"><span class="pl__circle"></span><span class="pl__title">JVM GC调优</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.html"><span class="pl__circle"></span><span class="pl__title">二叉树的各种遍历</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E9%93%BE%E8%B7%AF%E5%B1%82%20%E7%BD%91%E7%BB%9C%E5%B1%82%20UDP%20IO%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">链路层 网络层 UDP IO模型</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%B4%9D%E5%8F%B6%E6%96%AF.html"><span class="pl__circle"></span><span class="pl__title">贝叶斯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html"><span class="pl__circle"></span><span class="pl__title">背包问题</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/%E7%BD%91%E5%8D%A1%E4%B8%AD%E6%96%AD%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"><span class="pl__circle"></span><span class="pl__title">网卡中断负载均衡</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E7%BA%BF%E6%AE%B5%E6%A0%91.html"><span class="pl__circle"></span><span class="pl__title">线段树</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9C%A8%E6%8E%92%E8%A1%8C%E6%A6%9C%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"><span class="pl__circle"></span><span class="pl__title">桶排序在排行榜问题中的应用</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%B9%B6%E6%9F%A5%E9%9B%86.html"><span class="pl__circle"></span><span class="pl__title">并查集</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88.html"><span class="pl__circle"></span><span class="pl__title">JDK 中的并发集合</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html"><span class="pl__circle"></span><span class="pl__title">定时器（Timer）的实现</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%A0%86.html"><span class="pl__circle"></span><span class="pl__title">堆</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E5%9B%9E%E6%BA%AF.html"><span class="pl__circle"></span><span class="pl__title">回溯</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html"><span class="pl__circle"></span><span class="pl__title">二进制索引树(树状数组)</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html"><span class="pl__circle"></span><span class="pl__title">TCP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8.html"><span class="pl__circle"></span><span class="pl__title">RST及java socket关闭后读写的各种异常</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"><span class="pl__circle"></span><span class="pl__title">Netty3 源码分析</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="网络 pl__all" href="/%E7%BD%91%E7%BB%9C/2014/07/26/Netty3%204%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB.html"><span class="pl__circle"></span><span class="pl__title">Netty3 4线程模型的区别</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="数据库 pl__all" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2014/07/26/MySQL%E6%80%BB%E7%BB%93.html"><span class="pl__circle"></span><span class="pl__title">MySQL总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/Mode%20Switch%20%E5%92%8C%20Context%20Switch.html"><span class="pl__circle"></span><span class="pl__title">Mode Switch 和 Context Switch</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Lock-Free%20%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Lock-Free 算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/LCA%20%E5%92%8C%20RMQ.html"><span class="pl__circle"></span><span class="pl__title">LCA 和 RMQ</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/KMP.html"><span class="pl__circle"></span><span class="pl__title">KMP</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"><span class="pl__circle"></span><span class="pl__title">Java内存模型和Volatile</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html"><span class="pl__circle"></span><span class="pl__title">Java 并发基本知识</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Http%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84cache%E6%9C%BA%E5%88%B6.html"><span class="pl__circle"></span><span class="pl__title">Http协议中的cache机制</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="算法 pl__all" href="/%E7%AE%97%E6%B3%95/2014/07/26/Hash%20&%20Rabin-Karp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.html"><span class="pl__circle"></span><span class="pl__title">Hash & Rabin-Karp字符串查找算法</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/Executor%20%E4%B9%8B%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">Executor 之 线程池及定时器</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/C%E6%80%BB%E7%BB%93%20+%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html"><span class="pl__circle"></span><span class="pl__title">C及虚拟内存总结</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="cache pl__all" href="/cache/2014/07/26/Cache%20%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA.html"><span class="pl__circle"></span><span class="pl__title">Cache 相关理论</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="c和os pl__all" href="/c%E5%92%8Cos/2014/07/26/CPU%20Cache%20%E4%B8%8E%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.html"><span class="pl__circle"></span><span class="pl__title">CPU Cache & False Sharing & 存储器层次结构</span><span class="pl__date">Jul 2014</span></a>
        
          <a class="并发 pl__all" href="/%E5%B9%B6%E5%8F%91/2014/07/26/AQS%20%E5%92%8C%20%E9%AB%98%E7%BA%A7%E5%90%8C%E6%AD%A5%E5%99%A8.html"><span class="pl__circle"></span><span class="pl__title">AQS 和 高级同步器</span><span class="pl__date">Jul 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140726">TCP</h1>
  <div style="line-height: 1.5; color: #2c3f51;">
<div></div>
<div>
</div><div>

<p style="margin: 0 0 1.1em;"></p>
<div><div><div>
<ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">TCP</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">1. 有连接的：建立和终止</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">三次握手</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">四次挥手</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">状态变换：</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">MSS</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">2MSL（TIME_WAIT）状态</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">RST</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">同时打开</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">同时关闭</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">并发TCP服务器</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">backlog队列</a></li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">2. 滑动窗口</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">urgent mode</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">delayed ack</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">滑动窗口的工作方式</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">问题1：零窗口</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">问题2：糊涂窗口综合症 (silly window syndrome)</a></li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">3. 可靠性：超时重传</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">4. 顺序性</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">快速重传</a></li>
</ul>
</li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">5. 拥塞控制</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">探测堵塞</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">控制速度</a><ul style="margin-top: 0; margin-bottom: 15px; list-style-type: none;">
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">慢启动</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">拥塞避免</a></li>
<li><a style="background: transparent; color: #1980e6; text-decoration: none;">快速恢复</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<p style="margin: 0 0 1.1em;">ack是接收端期望接收到的数据序号，等于已接收到序号+1。</p></div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">1. 有连接的：建立和终止</h1>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">三次握手</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>SYN ACK+SYN ACK</li>
<li>被动连接端的ACK通过SYN<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">捎带</code></li>
<li>交换双方的： 初始序列号 / MSS / 窗口大小（？）</li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">四次挥手</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>FIN ACK FIN ACK</li>
<li>单向关闭</li>
<li>半关闭。通过半关闭向另一端告知数据发送完毕。</li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">状态变换：</h2>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1401174323234.png" name="c6428ae2-b0b5-4fc5-835a-01b6b0e551dc" src="/assets/img/1b7d77e4bd3391e09d1ada152392c072.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1401174353330.png" name="e8c6cd20-be3f-4c5e-b2f6-be429eff673d" src="/assets/img/6d971061f8715b70ddb1b19ff0397478.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">主动关闭方的状态：</p>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>FIN_WAIT_1 ：发送 FIN 后等待对方的 ACK</li>
<li>FIN_WAIT_2 ：收到对方对自己 FIN 的 ACK 后等待对方的 FIN</li>
<li>TIME_WAIT  ：收到对方的 FIN 并发送 ACK 后进入该状态</li>
</ul>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">MSS</h2>
<p style="margin: 0 0 1.1em;">根据物理层的MTU计算，避免IP层分段</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">2MSL（TIME_WAIT）状态</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><em>主动关闭端</em>在发送对FIN的最后一个ACK后，等待2MSL时间。MSL, max segment lifetime，一个segment在网络中存活的最长时间。</li>
</ol>
<p style="margin: 0 0 1.1em;">原因：</p>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>被动关闭端可能没有收到ACK而重发FIN，如果不等待，这个重发的FIN可能将新的连接关闭掉；</li>
<li>网络中可能还有在传输的旧的重传报文段，可能被当做新连接的数据。</li>
</ul>
<p style="margin: 0 0 1.1em;">等2MSL：一个ACK+FIN的最大时间，如果在这个时间段内没有收到重发的FIN，认为对方已经收到ACK正确关闭了。</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>处于2MSL状态的端口不能被使用。客户端每次连接随机选一个端口，因此没有影响；而服务器端固定端口，因此在服务器端主动关闭，必须等待一段时间才能重新绑定到原端口。设置选项<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">SO_REUSEADDR</code>可以取消这个设定。</li>
<li>在此期间拒绝任何收到的数据。</li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">RST</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>TCP模块会在自己认为的异常时刻发送RST；</li>
<li>不会对RST发ACK，立即丢弃缓冲区中的数据；</li>
<li>用RST而不是FIN关闭连接，称为<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">abortive release</code>（相对<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">orderly release</code>）；api会通知应用层连接是异常关闭的。</li>
<li>常见的产生时机： <br/>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>连接到/发送数据到没有使用的端口，收到RST</li>
<li>关闭连接时接收缓冲区还有数据没被消费，将发送RST</li>
<li>向一个已经close()的socket发送数据，将收到RST —- close和shutdown虽然都是发送FIN关闭连接，但前者的语义是关闭读写，后者是关闭写，但依然能读。</li></ul></li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">同时打开</h2>
<p style="margin: 0 0 1.1em;">两端都是主动打开。SYN SYN+ACK / SYN SYN+ACK。4个segment。</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1410048593357.png" name="a8917ee0-181e-4182-ac3c-7a74a896d776" src="/assets/img/7598bd90f97cb54a18adc1ed61e29d3d.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">同时关闭</h2>
<p style="margin: 0 0 1.1em;">两端都是主动关闭，FIN ACK / FIN ACK，两端最后都进入2MSL状态。</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1410048627139.png" name="2f2f8ec7-5b67-4ccf-ae4f-73d66aa11b6c" src="/assets/img/5231b9be12bf35e044add3b05c5427f9.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">并发TCP服务器</h2>
<p style="margin: 0 0 1.1em;">Listen状态的socket在接收连接请求后，内核会创建一个新的established状态的socket；原socket依然是listen状态；二者在服务器端使用同一个端口。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">backlog队列</h2>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>服务器端的TCP模块内有一个连接队列，保存所有已被TCP接受（三次握手完成），但未被应用层接受的连接；队列的长度由应用层指定，称为backlog；</li>
<li><em>TCP连接的建立</em> 和 <em>应用层得到一个已经建立的连接</em>，是一个<em>生产者消费者模型</em>；应用层无法拒绝客户端的连接请求。</li>
<li>客户端发起连接成功后，该连接在服务器端可能只在backlog队列中，此时客户端如果发送数据，将被缓存在TCP接收buffer中；</li>
<li>backlog队列满后，不会回应发来的FIN，让客户端重试。如果backlog队列一直满，客户端终将超时。</li>
</ol>
</div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">2. 滑动窗口</h1>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">urgent mode</h2>
<p style="margin: 0 0 1.1em;">URG标志位为1时，说明报文段是紧急数据，需要尽快被应用进程接收和处理。普通数据在接收端是按序交付给应用进程的，紧急模式在两端间建立了一个<strong style="font-weight: bold;">独立于普通数据的<em>逻辑信道</em></strong>，接收端通常将普通数据和紧急数据分开存放，二者之间不遵守有序的规则，允许越过普通数据直接读取后面的紧急数据。这种数据也被称为”带外数据“（out-of-band data），但实际上，带外数据和普通数据是共享物理信道传输的。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">delayed ack</h2>
<p style="margin: 0 0 1.1em;">接收端不立即发送ack，而是等待一段时间，和数据一起发送，或和另一个ack合并成一个发送。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">滑动窗口的工作方式</h2>
<p style="margin: 0 0 1.1em;">窗口通知： <br/>
发送端维护发送窗口大小（不在包中传输），接收端在ACK中告知接收窗口大小；</p>
<p style="margin: 0 0 1.1em;">发送窗口初始是发送缓冲区大小，接收窗口初始是接收缓冲区大小；缓冲区决定窗口的最大值；</p>
<p style="margin: 0 0 1.1em;">发送窗口一般包括3个部分，从左到右：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>已发送但未收到ACK的数据</li>
<li>可以立即发送的数据</li>
<li>空闲空间；</li>
</ol>
<p style="margin: 0 0 1.1em;">接收窗口就是接收缓冲区还剩多少空间，接收端处理能力越强，从缓冲区提取数据的速度就越快，接收窗口就越大；</p>
<p style="margin: 0 0 1.1em;">发送窗口大小由接收窗口决定，发送端收到ACK后：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>丢弃缓存中对应的数据，左沿向右移动；<strong style="font-weight: bold;">（收缩）</strong></li>
<li>根据ACK告知的接收窗口看是否需要移动右沿；已发送未 ACK 的数据 + 可立即发送数据 + 空闲 = 接收窗口；<strong style="font-weight: bold;">（扩张）</strong></li>
</ol>
<p style="margin: 0 0 1.1em;">作用：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>提高效率，可以同时发送多个数据；</li>
<li><strong style="font-weight: bold;">流量控制，适配不同处理能力的发送端和接收端</strong></li>
</ol>
<p style="margin: 0 0 1.1em;">最优窗口大小（即发送/接收缓冲区大小）的计算：</p>
<ul style="margin-top: 0; margin-bottom: 1.1em;"><li>尽量将两端之间的信道填满；</li>
<li>填满时，在信道上传输的数据 = 带宽（数据传输速度） * RTT，两个缓冲区应至少为这个大小</li>
</ul>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">问题1：零窗口</h2>
<p style="margin: 0 0 1.1em;">接收端接收缓冲区满时，ACK中接收窗口为0，阻止发送端发送数据。发送方需要在接收方缓冲区空出来时得到通知，因此在发现零窗口后会进行<em>窗口探测</em>，即定时发送含有1字节内容的segment，通过其ACK查询接收方的接收窗口。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">问题2：糊涂窗口综合症 (silly window syndrome)</h2>
<p style="margin: 0 0 1.1em;">现象：大量的小segment被传输（payload太小），造成网络利用率低下</p>
<p style="margin: 0 0 1.1em;">发送端和接收端都有可能引起这种情况：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>发送端每次只发送少量数据；</li>
<li>接收端的处理能力不够或应用层没有即时从接收缓冲区中取数据，接收窗口一直很小，发送端只能发小segment。</li>
</ol>
<p style="margin: 0 0 1.1em;">解决： <br/>
<em>* 发送端: nagle算法 *</em></p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>只针对<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">小segment</code>的<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">stop-wait</code>协议，大segment不受影响；</li>
<li>在前一个 <strong style="font-weight: bold;">小segment</strong>（小于MSS）的ack未到来前，缓存并合并其他要发送的小segment；</li>
<li>如果ack回来的很快，合并不了多少数据；</li>
<li>ack通常是delayed，会导致数据发送的延时；不适合实时性的应用（可以取消）；</li>
<li>目的是减少segment数目。</li>
</ol>
<p style="margin: 0 0 1.1em;"><em>* 接收端: *</em> <br/>
在接收端，当接收窗口小于一定阈值（如MSS一半）时，无论是数据确认ACK，还是对窗口探测的回应ACK，都宣告接收窗口为0，阻止发送端发送小报文段。</p>
</div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">3. 可靠性：超时重传</h1>
<p style="margin: 0 0 1.1em;">每个segment发送后都会有一个计时器负责接收ACK，如果超时，则重新发送该segment。</p>
<p style="margin: 0 0 1.1em;">首先要预测当前发送的segment的RTT： <br/>
R = αR + (1-α)M，M是测量到的RTT，R是估计的RTT。</p>
<p style="margin: 0 0 1.1em;">然后计算RTO(Retransmission TimeOut): <br/>
简单版：RTO = R*β <br/>
复杂版，将RTT的估计值，RTT的偏差的估计值也考虑在内：</p>
</div><div>
<pre style="font-family: Source Code Pro,monospace; font-size: .9em; white-space: pre-wrap; display: block; padding: 2px; margin: 0 0 1.1em; line-height: 1.45; word-break: break-word; word-wrap: break-word; color: #333; background-color: rgba(102,128,153,0.05); border: 0; border-radius: 5px; text-align: start; background: #f6f6f6;" xml:space="preserve"><code style="font-family: Source Code Pro,monospace; font-size: inherit; padding: 18px 28px; color: #f8f8f2; background-color: transparent; white-space: pre-wrap; border-radius: 0; display: block; background: #23241f;"><span style="color: #66d9ef;">Err</span> = <span style="color: #66d9ef;">M</span> - <span style="color: #66d9ef;">R</span>  <span style="color: #75715e;">#Err是实际RTT和估计RTT的差值</span>
<span style="color: #66d9ef;">R</span> = <span style="color: #66d9ef;">R</span> + g*<span style="color: #66d9ef;">Err</span> = (<span style="color: #ae81ff;">1</span>-g)*<span style="color: #66d9ef;">R</span> + g*<span style="color: #66d9ef;">M</span> <span style="color: #75715e;">#计算估计RTT，和之前的算法一模一样</span>
<span style="color: #66d9ef;">D</span> = <span style="color: #66d9ef;">D</span> + h*(|<span style="color: #66d9ef;">Err</span>| - <span style="color: #66d9ef;">D</span>) <span style="color: #75715e;"># 计算估计偏差，”估计偏差“指的是 估计RTT 和 真实RTT  的差值。这个算法和估计RTT的计算方法是一样的</span>
<span style="color: #66d9ef;">RTO</span> = <span style="color: #66d9ef;">R</span> + <span style="color: #ae81ff;">4</span>D <span style="color: #75715e;">#</span></code></pre>
<p style="margin: 0 0 1.1em;">多次重传时RTO的exponential backoff（指数退避）</p>
</div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">4. 顺序性</h1>
<p style="margin: 0 0 1.1em;">数据乱序到达，接收端可以不丢弃，而是缓冲起来，组装成有序后交付给应用进程。</p>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">快速重传</h2>
<p style="margin: 0 0 1.1em;">接收端在接收到乱序segment时，用重复ACK提醒发送端空洞的存在，使之发送丢失数据，保证可靠性。 <br/>
例：发送端发送了5/6/7/8/9，假如接收端按顺序接收5/9/7/8，6丢失了，则在接收到9/7/8后均会发送ACK=6；当发送端收到3个重复的值为6的ack时认为6丢失了，打断6的超时timer并立即重新发送。 <br/>
为什么阈值是3呢？这是一个权衡，<strong style="font-weight: bold;">重复ACK可能是由段丢失引起的，但也可能只是段乱序到达了而已</strong>，比如5/7/8/6/9，在7和8处会发送两个重复的ACK，但是紧接着6就到了，接收端重组后一切正常，此时也不会触发发送端的<em>快速重传</em>。</p>
<p style="margin: 0 0 1.1em;">优点：接收端利用空洞后的segment比超时更快地检测到丢失片段，效率更高。</p>
</div><div>
<h1 style="font-size: 2.6em; margin: 1.2em 0; font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; text-align: start;">5. 拥塞控制</h1>
<p style="margin: 0 0 1.1em;">问题：堵塞 –&gt; 数据丢失 –&gt; 超时重传 –&gt; 更堵塞</p>
<p style="margin: 0 0 1.1em;">解决办法：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>探测堵塞; </li>
<li>发现堵塞时控制自己发送数据的速度。</li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">探测堵塞</h2>
<p style="margin: 0 0 1.1em;">上文已经提到了各种推测segment丢失的办法：超时 / 重复ACK，<strong style="font-weight: bold;">一旦出现段丢失则认为堵塞</strong>。</p>
<p style="margin: 0 0 1.1em;">但是注意，这两种情况下的阻塞程度不一样：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>超时：严重阻塞，发送了若干段但是一个ACK都没回来；</li>
<li>重复ACK：轻微阻塞，或者没有阻塞。因为后续的段到达了，只有中间某些段没有到达。</li>
</ol>
</div><div>
<h2 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 2.15em; margin: 1.2em 0; text-align: start;">控制速度</h2>
<p style="margin: 0 0 1.1em;">单纯的滑动窗口中，发送方通过接收方通告的接收窗口大小调整发送窗口，从而控制发送速度；为了拥塞控制，TCP还会在发送端维护一个<em>拥塞窗口</em>，<code style="font-family: Source Code Pro,monospace; font-size: .9em; padding: 2px 4px; color: #c7254e; background-color: #f9f2f4; white-space: normal; border-radius: 4px;">真实发送窗口= min(接收窗口，拥塞窗口)</code>。</p>
<p style="margin: 0 0 1.1em;">拥塞控制有3个阶段：</p>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li>慢启动(slow start) </li>
<li>拥塞避免(congestion avoidance)</li>
<li>快速恢复（相对快速重传而言）</li>
</ol>
<p style="margin: 0 0 1.1em;">// cwnd： 拥塞窗口大小</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">慢启动</h3>
<p style="margin: 0 0 1.1em;">系统从slow start阶段开始。在这一阶段cwnd被置为1，只能发送1个segment；每收到1个ack，都给拥塞窗口+1，即下次可以发送2个段，下下次可以发送4个段，即乘性倍增。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">拥塞避免</h3>
<p style="margin: 0 0 1.1em;">当cwnd增长到某个阈值ssthresh(slow start threshhold)时，拥塞窗口进入congestion avoidance状态。此时发送窗口在每个窗口中所有片段都传输完毕后，将拥塞窗口+1，线性缓慢增长。</p>
<p style="margin: 0 0 1.1em;">在congestion avoidance状态下，一旦出现探测到拥塞，ssthresh 立即更新为当前cwnd的一半，随后分两种情况：如果是ACK超时检测到的拥塞，则进入slow start；<strong style="font-weight: bold;">如果是重复ACK，则进入快速恢复阶段</strong>。</p>
</div><div>
<h3 style="font-family: inherit; font-weight: bold; line-height: 1.1; color: inherit; margin-top: 21px; margin-bottom: 10.5px; font-size: 1.7em; margin: 1.2em 0; text-align: start;">快速恢复</h3>
<ol style="margin-top: 0; margin-bottom: 1.1em;"><li><p style="margin: 0 0 1.1em;">cwnd增加3个segment的长度（加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络），以后每收到一个重复的ACK，就再增加1个segment长度。这是因为一个重复ACK说明有一个段已被发送出去，可以发送另一个段了；</p></li>
<li><p style="margin: 0 0 1.1em;">当收到一个非重复ACK时，说明对方的数据接收完整了，发送端将cwnds复原为sthresh（已经减半了），重新回到congestion avoidance状态。</p></li>
</ol>
<p style="margin: 0 0 1.1em;">分开处理的原因正如前所述，两种情况表达的拥塞程度不同。对超时表达的严重堵塞，需严厉地立刻降低发送速率，因此直接进入慢启动阶段；对重复ACK，说明双方仍然有数据流动，我们不希望执行slow start突然减少数据流。</p>
<p style="margin: 0 0 1.1em;">如果在slow start阶段就出现丢失数据，则slow start立刻开始，ssthresh更新为cwnd的一半。</p>
<p style="margin: 0 0 1.1em;"><img alt="Alt text" class="en-media" longdesc="./1400765487595.png" name="4c1097c3-df4b-4994-a311-eca5c6892e64" src="/assets/img/4a26ce1a352129b148ba26f27f53016d.png" style="border: 0; vertical-align: middle; max-width: 100%;" title=""/></p>
<p style="margin: 0 0 1.1em;">总体来说，拥塞窗口的状态变迁是一个试探性的过程。slow start阶段起步速度低，不太可能出现拥塞，因此发送速度可以快速攀升；congestion avoidance阶段速度接近饱和，采用更保守的方式，速度缓慢增长逼近极限。一旦探测到拥塞，就将slow start的拐点降低为当前拥塞窗口的一半，且如果是严重堵塞，则立即重置，避免网络负担；如果是轻微拥塞，则快速恢复。</p></div><div></div></div>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=http://novoland.github.io/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html&text=TCP" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=http://novoland.github.io/%E7%BD%91%E7%BB%9C/2014/07/26/TCP.html&title=TCP" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->
<!-- 
      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">目录</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div> -->
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>
    <button id="js-toc"><span id="icon-list" class="fa fa-list-ul"></span></button>
    <div id="post__toc">
      <span id="post__toc-title">目录</span>
      <ul id="post__toc-ul"></ul>
    </div>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </body>
</html>
